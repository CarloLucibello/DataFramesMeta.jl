var documenterSearchIndex = {"docs":
[{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Metaprogramming tools for DataFrames.jl objects to provide more convenient syntax.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl has the functions select, transform, and combine, as well as the in-place select! and transform! for manipulating data frames. DataFramesMeta.jl provides the macros  @select, @transform, @combine, @select!, and @transform! to mirror these functions with  more convenient syntax. Inspired by dplyr in R  and LINQ in C#. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition, DataFramesMeta provides ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@orderby, for sorting data frames\n@subset and @subset!, for keeping rows of a data frame matching a given condition\nRow-wise versions of the above macros in the form of @rtransform, @rtransform!, @rselect, @rselect!, @rorderby, @rsubset, and @rsubset!.\n@by, for grouping and combining a data frame in a single step\n@with, for working with the columns of a data frame with high performance and  convenient syntax\n@eachrow and @eachrow! for looping through rows in data frame, again with high performance and  convenient syntax. \n@byrow for applying functions to each row of a data frame (only supported inside other macros).\n@passmissing for propagating missing values inside row-wise DataFramesMeta.jl transformations.\n@chain, from Chain.jl for piping the above macros together, similar to magrittr's %>% in R. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See below the convenience of DataFramesMeta compared to DataFrames.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(a = [1, 2], b = [3, 4]);\n\n# With DataFrames\ntransform(df, [:a, :b] => ((a, b) -> a .* b .+ first(a) .- sum(b)) => :c);\n\n# With DataFramesMeta\n@transform(df, :c = :a .* :b .+ first(:a) .- sum(:b))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To reference columns inside DataFramesMeta macros, use Symbols. For example, use :x to refer to the column df.x. To use a variable varname representing a Symbol to refer to  a column, use the syntax $varname. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Use passmissing  to propagate missing values more easily. See ?passmissing for  details. passmissing is defined in Missings.jl but exported by DataFramesMeta for convenience. ","category":"page"},{"location":"#Provided-macros","page":"Introduction","title":"Provided macros","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nNewer versions of DataFrames.jl support the operators Between, All, Cols, and Not when selecting and transforming columns. DataFramesMeta does not currently support this syntax. ","category":"page"},{"location":"#@select-and-@select!","page":"Introduction","title":"@select and @select!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Column selections and transformations. Only newly created columns are kept.  Operates on both a DataFrame and a GroupedDataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select returns a new data frame with newly allocated columns, while @select! mutates the original data frame and returns it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When given a GroupedDataFrame, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@select(df, :x, :y)\n@select(df, :x2 = 2 * :x, :y)\n@select(gd, :x2 = 2 .* :y .* first(:y))\n@select!(df, :x, :y)\n@select!(df, :x = 2 * :x, :y)\n@select!(gd, :y = 2 .* :y .* first(:y))","category":"page"},{"location":"#@transform-and-@transform!","page":"Introduction","title":"@transform and @transform!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Add additional columns based on keyword arguments. Operates on both a  DataFrame and a GroupedDataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform returns a new data frame with newly allocated columns, while @transform! mutates the original data frame and returns it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When given a GroupedDataFrame, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@transform(df, :x, :y)\n@transform(df, :x2 = 2 * :x, :y)\n@transform(gd, :x2 = 2 .* :y .* first(:y))\n@transform!(df, :x, :y)\n@transform!(df, :x = 2 * :x, :y)\n@transform!(gd, :y = 2 .* :y .* first(:y))","category":"page"},{"location":"#@subset-and-@subset!","page":"Introduction","title":"@subset and @subset!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Select row subsets. Operates on both a DataFrame and a GroupedDataFrame.  @subset always returns a freshly-allocated data frame whereas  @subset! modifies the data frame in-place.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Statistics\ndf = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\noutside_var = 1;\n@subset(df, :x .> 1)\n@subset(df, :x .> outside_var)\n@subset(df, :x .> outside_var, :y .< 102)  # the two expressions are \"and-ed\"\n@subset(gd, :x .> mean(:x))","category":"page"},{"location":"#@combine","page":"Introduction","title":"@combine","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Summarize, or collapse, a grouped data frame by performing transformations at the group level and  collecting the result into a single data frame. Also works on a DataFrame, which  acts like a GroupedDataFrame with one group. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Examples:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@combine(gd, :x2 = sum(:y))\n@combine(gd, :x2 = :y .- sum(:y))\n@combine(gd, $AsTable = (n1 = sum(:y), n2 = first(:y)))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Requires a DataFrame or GroupedDataFrame as the first argument, unlike  combine from DataFrames.jl. For instance, @combine((a = sum(:x), b = sum(:y)), gd)  will fail because @combine requires a GroupedDataFrame or a DataFrame  as the first argument. The following, however, will work.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@combine(gd, $AsTable = (a = sum(:x), b = sum(:y)))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For arguments which return a table-like object, such as (a = sum(:x), b = sum(:y)), above, @combine only allows one argument and it must be the second positional argument.  Consider the call ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@combine(gd, $AsTable = (a = sum(:x), b = sum(:y)), c = first(:x))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"the above will fail because @combine does not accept a \"keyword argument\"-style column  creation after a \"return a table\"-style column creation call. ","category":"page"},{"location":"#@orderby","page":"Introduction","title":"@orderby","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Sort rows in a DataFrame by values in one of several columns or a  transformation of columns. Only operates on DataFrames and not GroupedDataFrames. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\n@orderby(df, -1 .* :x)\n@orderby(df, :x, :y .- mean(:y))","category":"page"},{"location":"#@with","page":"Introduction","title":"@with","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"@with creates a scope in which all symbols that appear are aliases for the columns in a DataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = 1:3, y = [2, 1, 2])\nx = [2, 1, 0]\n\n@with(df, :y .+ 1)\n@with(df, :x + x)  # the two x's are different\n\nx = @with df begin\n    res = 0.0\n    for i in 1:length(:x)\n        res += :x[i] * :y[i]\n    end\n    res\nend\n\n@with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\n@with creates a function, so scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nBecause @with creates a function, be careful with the use of return. function data_transform(df; returnearly = false)\n    if returnearly\n        @with df begin \n            z = :x + :y\n            return z\n        end\n    else \n        return [1, 2, 3]\n    end\n\n    return [4, 5, 6]\nendThe above function will return [4, 5, 6] because the return inside the @with applies to the anonymous function created by @with. Given that @eachrow (below) is implemented with @with, the same caveat applies to  @eachrow blocks. ","category":"page"},{"location":"#@eachrow-and-@eachrow!","page":"Introduction","title":"@eachrow and @eachrow!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Act on each row of a data frame. Includes support for control flow and begin end  blocks. Since the \"environment\" induced by @eachrow df is implicitly a  single row of df, one uses regular operators and comparisons instead of  their elementwise counterparts as in @with. Does not change the input data  frame argument.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow! is identical to @eachrow but acts on a data frame in-place, modifying the input.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\ndf2 = @eachrow df begin \n    :A = :B + 1\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow introduces a function scope, so a let block is required here to create  a scope to allow assignment of variables within @eachrow. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\nlet x = 0.0\n    @eachrow df begin\n        if :A < :B\n            x += :B * :C\n        end\n    end\n    x\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow also supports special syntax for allocating new columns to make @eachrow more useful for data transformations. The syntax @newcol :x::Vector{Int} allocates a new column :x with an Vector container with eltype Int. Here is an example where two new columns are added:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\ndf2 = @eachrow df begin\n    @newcol :colX::Vector{Float64}\n    @newcol :colY::Vector{Union{Int,Missing}}\n    :colX = :B == 2 ? pi * :A : :B\n    if :A > 1\n        :colY = :A * :B\n    else\n        :colY = missing\n    end\nend","category":"page"},{"location":"#Row-wise-transformations-with-@byrow-and-@rtransform/@rselect/etc.","page":"Introduction","title":"Row-wise transformations with @byrow and @rtransform/@rselect/etc.","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"@byrow provides a convenient syntax to apply operations by-row, without having to vectorize manually. Additionally, the macros @rtransform, @rtransform!, @rselect, @rselect!,  @rorderby, @rsubset, and @rsubset! use @byrow by default.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl provides the function wrapper ByRow. ByRow(f)(x, y) is roughly equivalent to f.(x, y). DataFramesMeta.jl allows users  to construct expressions using ByRow function wrapper with the  syntax @byrow or the row-wise macros @rtransform, etc.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@byrow is not a \"real\" macro and cannot be used outside of  DataFramesMeta.jl macros. However its behavior within DataFramesMeta.jl macros should be indistinguishable from externally defined macros.  Thought of as a macro @byrow accepts a single argument and  creates an anonymous function wrapped in ByRow.  For example,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform(df, @byrow :y = :x == 1 ? true : false)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"is equivalent to","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, :x => ByRow(x -> x == 1 ? true, false) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following macros accept @byrow:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform and @transform!, @select, @select!, and @combine.  @byrow can be used in the left hand side of expressions, e.g. @select(df, @byrow z = :x * :y). \n@subset, @subset! and @orderby, with syntax of the form @subset(df, @byrow :x > :y)\n@with, where the anonymous function created by @with is wrapped in ByRow, as in @with(df, @byrow :x * :y).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To avoid writing @byrow multiple times when performing multiple operations, it is allowed to use@byrow at the beginning of a block of  operations. All transformations in the block will operate by row.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> @subset df @byrow begin\n           :a > 1\n           :b < 5\n       end\n1×2 DataFrame\n Row │ a      b     \n     │ Int64  Int64 \n─────┼──────────────\n   1 │     2      4","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@byrow can be used inside macros which accept GroupedDataFrames, however, like with ByRow in DataFrames.jl, when @byrow is used, functions do not take into account the grouping, so for example the result of @transform(df, @byrow y = f(:x)) and  @transform(groupby(df, :g), @byrow :y = f(:x)) is the same.","category":"page"},{"location":"#Propagating-missing-values-with-@passmissing","page":"Introduction","title":"Propagating missing values with @passmissing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Many Julia functions to not automatically propagate missing values. For instance,  parse(Int, missing) will error. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Missings.jl provides the passmissing function-wrapper to help get around these roadblocks: passmissing(f)(args...) will return missing if any of args is missing. Similarly, DataFramesMeta.jl provides the @passmissing function to wrap the anonymous functions created by row-wise transformations in DataFramesMeta.jl  in Missings.passmissing.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The expression ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform df @byrow @passmissing :c = f(:a, :b)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"is translated to ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:a, :b] => ByRow(passmissing(f)) => :c)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See more examples below.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> no_missing(x::Int, y::Int) = x + y;\n\njulia> df = DataFrame(a = [1, 2, missing], b = [4, 5, 6])\n3×2 DataFrame\n Row │ a        b\n     │ Int64?   Int64\n─────┼────────────────\n   1 │       1      4\n   2 │       2      5\n   3 │ missing      6\n\njulia> @transform df @passmissing @byrow c = no_missing(:a, :b)\n3×3 DataFrame\n Row │ a        b      c\n     │ Int64?   Int64  Int64?\n─────┼─────────────────────────\n   1 │       1      4        5\n   2 │       2      5        7\n   3 │ missing      6  missing\n\njulia> df = DataFrame(x_str = [\"1\", \"2\", missing])\n3×1 DataFrame\n Row │ x_str\n     │ String?\n─────┼─────────\n   1 │ 1\n   2 │ 2\n   3 │ missing\n\njulia> @rtransform df @passmissing x = parse(Int, :x_str)\n3×2 DataFrame\n Row │ x_str    x\n     │ String?  Int64?\n─────┼──────────────────\n   1 │ 1              1\n   2 │ 2              2\n   3 │ missing  missing","category":"page"},{"location":"#Working-with-column-names-programmatically-with-\\","page":"Introduction","title":"Working with column names programmatically with \\$","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFramesMeta provides the special syntax \\$ for referring to  columns in a data frame via a Symbol, string, or column position as either a literal or a variable. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n\nnameA = :A\ndf2 = @transform(df, C = :B - $nameA)\n\nnameA_string = \"A\"\ndf3 = @transform(df, C = :B - $nameA_string)\n\nnameB = \"B\"\ndf4 = @eachrow df begin \n    :A = $nameB\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"\\$ can also be used to create new columns in a data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n\nnewcol = \"C\"\n@select(df, $newcol = :A + :B)\n\n@by(df, :B, $(\"A complicated\" * \" new name\") = first(:A))\n\nnameC = \"C\"\ndf3 = @eachrow df begin \n    @newcol $nameC::Vector{Int}\n    $nameC = :A\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFramesMeta macros do not allow mixing of integer column references with references  of other types. This means @transform(df, y = :A + $2), attempting to add the columns  df[!, :A] and df[!, 2], will fail. This is because in DataFrames, the command ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:A, 2] => (+) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will fail, as DataFrames requires the \"source\" column identifiers in a  source => fun => dest pair to all have the same type. DataFramesMeta adds one exception to this rule. Symbols and strings are allowed to be mixed inside DataFramesMeta macros.  Consequently, ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform(df, y = :A + $\"B\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will not error even though ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:A, \"B\"] => (+) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will error in DataFrames. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For consistency, this restriction in the input column types also applies to @with and @eachrow. You cannot mix integer column references with Symbol or string column  references in @with and @eachrow in any part of the expression, but you can mix  Symbols and strings. The following will fail:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n@eachrow df begin \n    :A = $2\nend\n\n@with df begin \n    $1 + $\"A\"\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"while the following will work without error","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow df begin \n    $1 + $2\nend\n\n@with df begin \n    $1 + $2\nend","category":"page"},{"location":"#Working-with-Symbols-without-referring-to-columns","page":"Introduction","title":"Working with Symbols without referring to columns","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To refer to Symbols without aliasing the column in a data frame, use ^. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\n@select(df, :x2 = :x, :x3 = ^(:x))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This rule applies to all DataFramesMeta macros.","category":"page"},{"location":"#Comparison-with-dplyr-and-LINQ","page":"Introduction","title":"Comparison with dplyr and LINQ","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A number of functions for operations on DataFrames have been defined. Here is a table of equivalents for Hadley's dplyr and common LINQ functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia             dplyr            LINQ\n---------------------------------------------\n@subset           filter           Where\n@transform        mutate           Select (?)\n@by                                GroupBy\ngroupby           group_by         GroupBy\n@combine          summarise/do\n@orderby          arrange          OrderBy\n@select           select           Select","category":"page"},{"location":"#Chaining-operations-together-with-@chain","page":"Introduction","title":"Chaining operations together with @chain","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To enable connecting multiple commands together in  a pipe, DataFramesMeta.jl re-exports the @chain macro from  Chain.jl. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Statistics \n\ndf = DataFrame(a = repeat(1:5, outer = 20),\n               b = repeat([\"a\", \"b\", \"c\", \"d\"], inner = 25),\n               x = repeat(1:20, inner = 5))\n\nx_thread = @chain df begin\n    @transform(:y = 10 * :x)\n    @subset(:a .> 2)\n    @by(:b, :meanX = mean(:x), :meanY = mean(:y))\n    @orderby(:meanX)\n    @select(:meanX, :meanY, :var = :b)\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By default, @chain places the value of the  previous expression into the first argument of the current expression. The placeholder _ is used to break that convention and refer to the argument returned from the previous  expression.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# Get the sum of all columns after \n# a few transformations\n@chain df begin \n    @transform(:y = 10 .* :x)\n    @subset(:a .> 2)\n    @select(:a, :y, :x)\n    reduce(+, eachcol(_))\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@chain also provides the @aside macro-flag to perform operations in the middle of a @chain block. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@chain df begin \n    @transform :y = 10 .* :x\n    @aside y_mean = mean(_.y) # From Chain.jl, not DataFramesMeta.jl\n    @select :y_standardize = :y .- y_mean\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"api/api.md\"]\nDepth = 3","category":"page"},{"location":"api/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Modules = [DataFramesMeta]\nPrivate = false","category":"page"},{"location":"api/api/#DataFramesMeta.@based_on-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@based_on","text":"@based_on(d, args...)\n\nDeprecated version of @combine, see: @combine\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@by-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@by","text":"@by(d::AbstractDataFrame, cols, e...)\n\nSplit-apply-combine in one step.\n\nArguments\n\nd : an AbstractDataFrame\ncols : a column indicator (Symbol, Int, Vector{Symbol}, etc.)\ne :  keyword arguments specifying new columns in terms of column groupings\n\nReturns\n\n::DataFrame\n\nTransformation inputs to @by can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, or as a series of keyword arguments. For example, the following are equivalent:\n\n@by df :g begin\n    :mx = mean(:x)\n    :sx = std(:x)\nend\n\nand\n\n@by(df, :g, mx = mean(:x), sx = std(:x))\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(\n            a = repeat(1:4, outer = 2),\n            b = repeat(2:-1:1, outer = 4),\n            c = 1:8);\n\njulia> @by(df, :a, :d = sum(:c))\n4×2 DataFrame\n Row │ a      d\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      6\n   2 │     2      8\n   3 │     3     10\n   4 │     4     12\n\njulia> @by df :a begin\n           :d = 2 * :c\n       end\n8×2 DataFrame\n Row │ a      d\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     1     10\n   3 │     2      4\n   4 │     2     12\n   5 │     3      6\n   6 │     3     14\n   7 │     4      8\n   8 │     4     16\n\njulia> @by(df, :a, :c_sum = sum(:c), :c_mean = mean(:c))\n4×3 DataFrame\n Row │ a      c_sum  c_mean\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      6      3.0\n   2 │     2      8      4.0\n   3 │     3     10      5.0\n   4 │     4     12      6.0\n\njulia> @by df :a begin\n           :c = :c\n           :c_mean = mean(:c)\n       end\n8×3 DataFrame\n Row │ a      c      c_mean\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      1      3.0\n   2 │     1      5      3.0\n   3 │     2      2      4.0\n   4 │     2      6      4.0\n   5 │     3      3      5.0\n   6 │     3      7      5.0\n   7 │     4      4      6.0\n   8 │     4      8      6.0\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@byrow-Tuple","page":"API","title":"DataFramesMeta.@byrow","text":"@byrow\n\nBroadcast operations within DataFramesMeta.jl macros.\n\n@byrow is not a \"real\" Julia macro but rather serves as a \"flag\" to indicate that the anonymous function created by DataFramesMeta to represent an operation should be applied \"by-row\".\n\nIf an expression starts with @byrow, either of the form @byrow :y = f(:x) in transformations or @byrow f(:x) in @orderby, @subset, and @with, then the anonymous function created by DataFramesMeta is wrapped in the DataFrames.ByRow function wrapper, which broadcasts the function so that it run on each row.\n\nExamples\n\njulia> df = DataFrame(a = [1, 2, 3, 4], b = [5, 6, 7, 8]);\n\njulia> @transform(df, @byrow :c = :a * :b)\n4×3 DataFrame\n Row │ a      b      c\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      5      5\n   2 │     2      6     12\n   3 │     3      7     21\n   4 │     4      8     32\n\njulia> @subset(df, @byrow :a == 1 ? true : false)\n1×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      5\n\nTo avoid writing @byrow multiple times when performing multiple operations, it is allowed to use@byrow at the beginning of a block of operations. All transformations in the block will operate by row.\n\njulia> @subset df @byrow begin\n           :a > 1\n           :b < 5\n       end\n1×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      4\n\nComparison with @eachrow\n\nTo re-cap, the @eachrow macro roughly transforms\n\n@eachrow df begin\n    :a * :b\nend\n\nto\n\nbegin\n    function tempfun(a, b)\n        for i in eachindex(a)\n            a[i] * b[i]\n        end\n    end\n    tempfun(df.a, df.b)\n    df\nend\n\nThe function * is applied by-row. But the result of those operations is not stored anywhere, as with for-loops in Base Julia. Rather, @eachrow and @eachrow! return data frames.\n\nNow consider @byrow. @byrow transforms\n\n@with df @byrow begin\n    :a * :b\nend\n\nto\n\ntempfun(a, b) = a * b\ntempfun.(df.a, df.b)\n\nIn contrast to @eachrow, @with combined with @byrow returns a vector of the broadcasted multiplication and not a data frame.\n\nAdditionally, transformations applied using @eachrow! modify the input data frame. On the contrary, @byrow does not update columns.\n\njulia> df = DataFrame(a = [1, 2], b = [3, 4]);\n\njulia> @with df @byrow begin\n           :a = 500\n       end\n2-element Vector{Int64}:\n 500\n 500\n\njulia> df\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\nComparison with @. and Base broadcasting\n\nBase Julia provides the broadasting macro @. and in many cases @. and @byrow will give equivalent results. But there are important deviations in behavior. Consider the setup\n\ndf = DataFrame(a = [1, 2], b = [3, 4])\n\nControl flow. @byrow allows for operations of the form if ... else and a ? b : c to be applied by row. These expressions cannot be broadcasted in Base Julia. @byrow also allows for expressions of the form a && b and a || b to be applied by row, something that is not possible in Julia versions below 1.7.\n\njulia> @with df @byrow begin\n           if :a == 1\n               5\n           else\n               10\n           end\n       end\n2-element Vector{Int64}:\n  5\n 10\n\njulia> @with df @. begin\n           if :a == 1\n               5\n           else\n               10\n           end\n       end # will error\n\nBroadcasting objects that are not columns. @byrow constructs an anonymous function which accepts only the columns of the input data frame and broadcasts that function. Consequently, it does not broadcast referenced objects which are not columns.\n\njulia> df = DataFrame(a = [1, 2], b = [3, 4]);\njulia> @with df @byrow :x + [5, 6]\n\nwill error, because the :x in the above expression refers   to a scalar Int, and you cannot do 1 + [5, 6].\n\nOn the other hand\n\n@with df @. :x + [5, 6]\n\nwill succeed, as df.x is a 2-element vector as is [5, 6].\n\nBecause ByRow inside transform blocks does not internally   use broadcasting in all circumstances, in the rare instance   that a column in a data frame is a custom vector type that   implements custom broadcasting, this custom behavior will   not be called with @byrow.\n\nBroadcasting expensive calls. In Base Julia, broadcasting evaluates calls first and then broadcasts the result. Because @byrow constructs an anonymous function and evaluates that function for every row in the data frame, expensive functions will be evaluated many times.\n\njulia> function expensive()\n           sleep(.5)\n           return 1\n       end;\n\njulia> @time @with df @byrow :a + expensive();\n  1.037073 seconds (51.67 k allocations: 3.035 MiB, 3.19% compilation time)\n\njulia> @time @with df :a .+ expensive();\n  0.539900 seconds (110.67 k allocations: 6.525 MiB, 7.05% compilation time)\n\n\nThis problem comes up when using the @. macro as well,   but can easily be fixed with $.\n\njulia> @time @with df @. :a + expensive();\n  1.036888 seconds (97.55 k allocations: 5.617 MiB, 3.20% compilation time)\n\njulia> @time @with df @. :a + $expensive();\n  0.537961 seconds (110.68 k allocations: 6.525 MiB, 6.73% compilation time)\n\nNo such solution currently exists with @byrow.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@combine-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@combine","text":"@combine(x, args...)\n\nSummarize a grouping operation\n\nArguments\n\nx : a GroupedDataFrame or AbstractDataFrame\nargs... : keyword arguments defining new columns\n\nInputs to @combine can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, or as a series of keyword arguments. For example, the following are equivalent:\n\n@combine df begin\n    :mx = mean(:x)\n    :sx = std(:x)\nend\n\nand\n\n@combine(df, :mx = mean(:x), :sx = std(:x))\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> d = DataFrame(\n            n = 1:20,\n            x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(d, :x);\n\njulia> @combine(g, :nsum = sum(:n))\n3×2 DataFrame\n Row │ x      nsum\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1     99\n   2 │     2     84\n   3 │     3     27\n\njulia> @combine g begin\n           :x2 = 2 * :x\n           :nsum = sum(:n)\n       end\n20×3 DataFrame\n Row │ x      x2     nsum\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2     99\n   2 │     1      2     99\n   3 │     1      2     99\n   4 │     1      2     99\n   5 │     1      2     99\n   6 │     1      2     99\n   7 │     1      2     99\n   8 │     1      2     99\n   9 │     1      2     99\n  10 │     2      4     84\n  11 │     2      4     84\n  12 │     2      4     84\n  13 │     2      4     84\n  14 │     2      4     84\n  15 │     2      4     84\n  16 │     3      6     27\n  17 │     3      6     27\n  18 │     3      6     27\n  19 │     3      6     27\n  20 │     3      6     27\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@eachrow!-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@eachrow!","text":"@eachrow!(df, body)\n\nAct on each row of a data frame in-place, similar to\n\nfor row in eachrow(df)\n    ... # Actions that modify `df`.\nend\n\nIncludes support for control flow and begin end blocks. Since the \"environment\" induced by @eachrow! df is implicitly a single row of df, use regular operators and comparisons instead of their elementwise counterparts as in @with. Note that the scope within @eachrow! is a hard scope.\n\neachrow! also supports special syntax for allocating new columns. The syntax @newcol x::Vector{Int} allocates a new uninitialized column :x with an Vector container with eltype Int.This feature makes it easier to use eachrow for data transformations. _N is introduced to represent the number of rows in the data frame, _DF represents the dataframe including added columns, and row represents the index of the current row.\n\nChanges to the rows directly affect df. The operation will modify the data frame in place. See @eachrow which employs the same syntax but allocates a fresh data frame.\n\nLike with @transform!, @eachrow! supports the use of $ to work with column names stored as variables. Using $ with a multi-column selector, such as a Vector of Symbols, is currently unsupported.\n\nArguments\n\ndf : an AbstractDataFrame\nexpr : expression operated on row by row\n\nReturns\n\nThe modified AbstractDataFrame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> let x = 0\n            @eachrow! df begin\n                if :A + :B == 3\n                    x += 1\n                end\n            end  #  This doesn't work without the let\n            x\n        end\n2\n\njulia> df2 = copy(df);\n\njulia> @eachrow! df2 begin\n           if :A > :B\n               :A = 0\n           end\n       end;\n\njulia> df2\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     0      1\n   3 │     0      2\n\njulia> df2 = copy(df);\n\njulia> @eachrow! df2 begin\n           @newcol :colX::Vector{Float64}\n           :colX = :B == 2 ? pi * :A : :B\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> varA = :A; varB = :B;\n\njulia> df2 = copy(df);\n\njulia> @eachrow! df2 begin\n           @newcol :colX::Vector{Float64}\n           :colX = $varB == 2 ? pi * $varA : $varB\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> x = [1, 1, 1];\n\njulia> @eachrow! df begin\n           x[row] = :A\n       end;\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> @eachrow! df begin\n           @newcol :m::Vector{Float64}\n           :m = mean(_DF[:, row])\n       end\n3×3 DataFrame\n Row │ A      B      m\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  2.0\n   2 │     2      1  1.66667\n   3 │     3      2  1.22222\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@eachrow-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@eachrow","text":"@eachrow(df, body)\n\nAct on each row of a data frame, producing a new dataframe. Similar to\n\nfor row in eachrow(copy(df))\n    ...\nend\n\nIncludes support for control flow and begin end blocks. Since the \"environment\" induced by @eachrow df is implicitly a single row of df, use regular operators and comparisons instead of their elementwise counterparts as in @with. Note that the scope within @eachrow is a hard scope.\n\neachrow also supports special syntax for allocating new columns. The syntax @newcol x::Vector{Int} allocates a new uninitialized column :x with an Vector container with eltype Int.This feature makes it easier to use eachrow for data transformations. _N is introduced to represent the number of rows in the data frame, _DF represents the DataFrame including added columns, and row represents the index of the current row.\n\nChanges to the rows do not affect df but instead a freshly allocated data frame is returned by @eachrow. Also note that the returned data frame does not share columns with df. See @eachrow! which employs the same syntax but modifies the data frame in-place.\n\nLike with @transform, @eachrow supports the use of $ to work with column names stored as variables. Using $ with a multi-column selector, such as a Vector of Symbols, is currently unsupported.\n\nArguments\n\ndf : an AbstractDataFrame\nexpr : expression operated on row by row\n\nReturns\n\nThe modified AbstractDataFrame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> let x = 0\n            @eachrow df begin\n                if :A + :B == 3\n                    x += 1\n                end\n            end  #  This doesn't work without the let\n            x\n        end\n2\n\njulia> @eachrow df begin\n            if :A > :B\n                :A = 0\n            end\n        end\n3×2 DataFrame\n Row │ A      B\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     0      1\n   3 │     0      2\n\njulia> df2 = @eachrow df begin\n           @newcol :colX::Vector{Float64}\n           :colX = :B == 2 ? pi * :A : :B\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> varA = :A; varB = :B;\n\njulia> df2 = @eachrow df begin\n           @newcol :colX::Vector{Float64}\n           :colX = $varB == 2 ? pi * $varA : $varB\n       end\n3×3 DataFrame\n Row │ A      B      colX\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  3.14159\n   2 │     2      1  1.0\n   3 │     3      2  9.42478\n\njulia> x = [1, 1, 1];\n\njulia> @eachrow df begin\n           x[row] = :A\n       end;\n\njulia> x\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> @eachrow df begin\n           @newcol :m::Vector{Float64}\n           :m = mean(_DF[:, row])\n       end\n3×3 DataFrame\n Row │ A      B      m\n     │ Int64  Int64  Float64\n─────┼───────────────────────\n   1 │     1      2  2.0\n   2 │     2      1  1.66667\n   3 │     3      2  1.22222\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@linq-Tuple{Any}","page":"API","title":"DataFramesMeta.@linq","text":"@linq df ...\n\nnote: Note\n@linq is deprecated. Use @chain instead. See ? @chain for details.\n\nGeneral macro that creates a mini DSL for chaining and macro calls.\n\nDetails\n\nThe following embedded function calls are equivalent to their macro version:\n\nwith\nwhere\nselect\ntransform\nby\ngroupby\norderby\ncombine\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(\n            a = repeat(1:4, outer = 2),\n            b = repeat(2:-1:1, outer = 4),\n            x = 1:8);\n\njulia> x1 = @linq transform(where(df, :a .> 2, :b .!= \"c\"), :y = 10 .* :x);\n\njulia> x1 = @linq by(x1, :b, :meanX = mean(:x), :meanY = mean(:y));\n\njulia> @linq select(orderby(x1, :b, -:meanX), :var = :b, :meanX, :meanY)\n2×3 DataFrame\n│ Row │ var   │ meanX   │ meanY   │\n│     │ Int64 │ Float64 │ Float64 │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ 6.0     │ 60.0    │\n│ 2   │ 2     │ 5.0     │ 50.0    │\n\njulia> @linq df |>\n           transform(y = 10 .* :x) |>\n           where(:a .> 2) |>\n           by(:b, :meanX = mean(:x), :meanY = mean(:y)) |>\n           orderby(:meanX) |>\n           select(:meanX, :meanY, var = :b)\n2×3 DataFrame\n│ Row │ meanX   │ meanY   │ var   │\n│     │ Float64 │ Float64 │ Int64 │\n├─────┼─────────┼─────────┼───────┤\n│ 1   │ 5.0     │ 50.0    │ 2     │\n│ 2   │ 6.0     │ 60.0    │ 1     │\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@orderby-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@orderby","text":"@orderby(d, i...)\n\nSort rows by values in one of several columns or a transformation of columns. Always returns a fresh DataFrame. Does not accept a GroupedDataFrame.\n\nWhen given a DataFrame, @orderby applies the transformation given by its arguments (but does not create new columns) and sorts the given DataFrame on the result, returning a new DataFrame.\n\nInputs to @orderby can come in two formats: a begin ... end block, in which case each line in the block is a separate ordering operation, and as mulitple arguments. For example, the following two statements are equivalent:\n\n@orderby df begin\n    :x\n    -:y\nend\n\nand\n\n@orderby(df, :x, -:y)\n\nArguments\n\nd : an AbstractDataFrame\ni... : expression for sorting\n\nIf an expression provided to @orderby begins with @byrow, operations are applied \"by row\" along the data frame. To avoid writing @byrow multiple times, @orderby also allows @byrowto be placed at the beginning of a block of operations. For example, the following two statements are equivalent.\n\n@orderby df @byrow begin\n    :x^2\n    :x^3\nend\n\nand\n\n@orderby df\n    @byrow :x^2\n    @byrow :x^3\nend\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> d = DataFrame(x = [3, 3, 3, 2, 1, 1, 1, 2, 1, 1], n = 1:10,\n                     c = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]);\n\njulia> @orderby(d, -1 .* :n)\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1     10  j\n   2 │     1      9  i\n   3 │     2      8  h\n   4 │     1      7  g\n   5 │     1      6  f\n   6 │     1      5  e\n   7 │     2      4  d\n   8 │     3      3  c\n   9 │     3      2  b\n  10 │     3      1  a\n\njulia> @orderby(d, sortperm(:c, rev = true))\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1     10  j\n   2 │     1      9  i\n   3 │     2      8  h\n   4 │     1      7  g\n   5 │     1      6  f\n   6 │     1      5  e\n   7 │     2      4  d\n   8 │     3      3  c\n   9 │     3      2  b\n  10 │     3      1  a\n\njulia> @orderby d begin\n    :x\n    abs.(:n .- mean(:n))\nend\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1      5  e\n   2 │     1      6  f\n   3 │     1      7  g\n   4 │     1      9  i\n   5 │     1     10  j\n   6 │     2      4  d\n   7 │     2      8  h\n   8 │     3      3  c\n   9 │     3      2  b\n  10 │     3      1  a\n\njulia> @orderby d @byrow :x^2\n10×3 DataFrame\n Row │ x      n      c\n     │ Int64  Int64  String\n─────┼──────────────────────\n   1 │     1      5  e\n   2 │     1      6  f\n   3 │     1      7  g\n   4 │     1      9  i\n   5 │     1     10  j\n   6 │     2      4  d\n   7 │     2      8  h\n   8 │     3      1  a\n   9 │     3      2  b\n  10 │     3      3  c\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rorderby-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rorderby","text":"rorderby(d, args...)\n\nRow-wise version of @orderby, i.e. all operations use @byrow by default. See @orderby for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rselect!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rselect!","text":"@rselect!(x, args...)\n\nRow-wise version of @select!, i.e. all operations use @byrow by default. See @select! for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rselect-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rselect","text":"@rselect(x, args...)\n\nRow-wise version of @select, i.e. all operations use @byrow by default. See @select for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rsubset!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rsubset!","text":"@rsubset!(d, i...)\n\nRow-wise version of @subset!, i.e. all operations use @byrow by default. See @subset! for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rsubset-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rsubset","text":"@rsubset(d, i...)\n\nRow-wise version of @subset, i.e. all operations use @byrow by default. See @subset for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rtransform!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rtransform!","text":"@rtransform!(x, args...)\n\nRow-wise version of @transform!, i.e. all operations use @byrow by default. See @transform! for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@rtransform-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@rtransform","text":"@rtransform(x, args...)\n\nRow-wise version of @transform, i.e. all operations use @byrow by default. See @transform for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@select!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@select!","text":"@select!(d, e...)\n\nMutate d in-place to retain only columns or transformations specified by e and return it. No copies of existing columns are made.\n\nArguments\n\nd : an AbstractDataFrame\ne :  keyword arguments specifying new columns in terms of existing columns or symbols to specify existing columns\n\nReturns\n\n::DataFrame\n\nInputs to @select! can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation or selector, or as a series of arguments and keyword arguments. For example, the following are equivalent:\n\n@select! uses the syntax @byrow to wrap transformations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@select!(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\nselect!(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transformations by row, @select! allows @byrow at the beginning of a block of select!ations (i.e. @byrow begin... end). All transformations in the block will operate by row.\n\nExamples\n\njulia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> df2 = @select!(df, :c, :a)\n8×2 DataFrame\n Row │ c      a\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      1\n   6 │     6      2\n   7 │     7      3\n   8 │     8      4\n\njulia> df === df2\ntrue\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> df2 = @select! df begin\n           :c\n           :x = :b + :c\n       end\n8×2 DataFrame\n Row │ c      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      3\n   3 │     3      5\n   4 │     4      5\n   5 │     5      7\n   6 │     6      7\n   7 │     7      9\n   8 │     8      9\n\njulia> df === df2\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@select-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@select","text":"@select(d, e...)\n\nSelect and transform columns.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ne :  keyword arguments specifying new columns in terms of existing columns or symbols to specify existing columns\n\nReturns\n\n::AbstractDataFrame\n\nInputs to @select can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation or selector, or as a series of arguments and keyword arguments. For example, the following are equivalent:\n\n@select df begin\n    :x\n    :y = :a .+ :b\nend\n\nand\n\n@select(df, :x, :y = :a .+ :b)\n\n@select uses the syntax @byrow to wrap transformations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@select(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\nselect(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transformations by row, @select allows @byrow at the beginning of a block of selectations (i.e. @byrow begin... end). All transformations in the block will operate by row.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> @select(df, :c, :a)\n8×2 DataFrame\n Row │ c      a\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      1\n   2 │     2      2\n   3 │     3      3\n   4 │     4      4\n   5 │     5      1\n   6 │     6      2\n   7 │     7      3\n   8 │     8      4\n\njulia> @select df begin\n           :c\n           :x = :b + :c\n       end\n8×2 DataFrame\n Row │ c      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      3\n   3 │     3      5\n   4 │     4      5\n   5 │     5      7\n   6 │     6      7\n   7 │     7      9\n   8 │     8      9\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@subset!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@subset!","text":"@subset!(d, i...)\n\nSelect row subsets in AbstractDataFrames and GroupedDataFrames, mutating the underlying data-frame in-place.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ni... : expression for selecting rows\n\nMultiple i expressions are \"and-ed\" together.\n\nIf given a GroupedDataFrame, @subset! applies transformations by group, and returns a fresh DataFrame containing the rows for which the generated values are all true.\n\nInputs to @subset! can come in two formats: a begin ... end block, in which case each line is a separate selector, or as multiple arguments. For example the following two statements are equivalent:\n\n@subset! df begin\n    :x .> 1\n    :y .< 2\nend\n\nand\n\n@subset!(df, :x .> 1, :y .< 2)\n\nnote: Note\n@subset! treats missing values as false when filtering rows. Unlike DataFrames.subset! and other Boolean operations with missing, @subset! will not error on missing values, and will only keep true values.\n\nIf an expression provided to @subset! begins with @byrow, operations are applied \"by row\" along the data frame. To avoid writing @byrow multiple times, @orderby also allows @byrowto be placed at the beginning of a block of operations. For example, the following two statements are equivalent.\n\n@subset! df @byrow begin\n    :x > 1\n    :y < 2\nend\n\nand\n\n@subset! df\n    @byrow :x > 1\n    @byrow :y < 2\nend\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> globalvar = [2, 1, 0];\n\njulia> @subset!(df, :x .> 1)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset!(df, :x .> globalvar)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset! df begin\n    :x .> globalvar\n    :y .== 3\nend\n0×2 DataFrame\n\njulia> d = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,\n                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(d, :x);\n\njulia> @subset!(g, :n .> mean(:n))\n8×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n   8 │    20      2\n\njulia> @subset! g begin\n           :n .> mean(:n)\n           :n .< 20\n       end\n7×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n\njulia> d = DataFrame(a = [1, 2, missing], b = [\"x\", \"y\", missing]);\n\njulia> @subset!(d, :a .== 1)\n1×2 DataFrame\n│ Row │ a      │ b       │\n│     │ Int64? │ String? │\n├─────┼────────┼─────────┤\n│ 1   │ 1      │ x       │\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@subset-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@subset","text":"@subset(d, i...)\n\nSelect row subsets in AbstractDataFrames and GroupedDataFrames.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ni... : expression for selecting rows\n\nMultiple i expressions are \"and-ed\" together.\n\nIf given a GroupedDataFrame, @subset applies transformations by group, and returns a fresh DataFrame containing the rows for which the generated values are all true.\n\nInputs to @subset can come in two formats: a begin ... end block, in which case each line is a separate selector, or as multiple arguments. For example the following two statements are equivalent:\n\n@subset df begin\n    :x .> 1\n    :y .< 2\nend\n\nand\n\n@subset(df, :x .> 1, :y .< 2)\n\nnote: Note\n@subset treats missing values as false when filtering rows. Unlike DataFrames.subset and other Boolean operations with missing, @subset will not error on missing values, and will only keep true values.\n\nIf an expression provided to @subset begins with @byrow, operations are applied \"by row\" along the data frame. To avoid writing @byrow multiple times, @orderby also allows @byrowto be placed at the beginning of a block of operations. For example, the following two statements are equivalent.\n\n@subset df @byrow begin\n    :x > 1\n    :y < 2\nend\n\nand\n\n@subset df\n    @byrow :x > 1\n    @byrow :y < 2\nend\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> globalvar = [2, 1, 0];\n\njulia> @subset(df, :x .> 1)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset(df, :x .> globalvar)\n2×2 DataFrame\n Row │ x      y\n     │ Int64  Int64\n─────┼──────────────\n   1 │     2      1\n   2 │     3      2\n\njulia> @subset df begin\n    :x .> globalvar\n    :y .== 3\nend\n0×2 DataFrame\n\njulia> d = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,\n                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(d, :x);\n\njulia> @subset(g, :n .> mean(:n))\n8×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n   8 │    20      2\n\njulia> @subset g begin\n           :n .> mean(:n)\n           :n .< 20\n       end\n7×2 DataFrame\n Row │ n      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │    12      1\n   2 │    13      1\n   3 │    15      2\n   4 │    16      2\n   5 │    17      3\n   6 │    18      1\n   7 │    19      1\n\njulia> d = DataFrame(a = [1, 2, missing], b = [\"x\", \"y\", missing]);\n\njulia> @subset(d, :a .== 1)\n1×2 DataFrame\n│ Row │ a      │ b       │\n│     │ Int64? │ String? │\n├─────┼────────┼─────────┤\n│ 1   │ 1      │ x       │\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@transform!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@transform!","text":"@transform!(d, i...)\n\nMutate d inplace to add additional columns or keys based on keyword arguments and return it. No copies of existing columns are made.\n\nArguments\n\nd : an AbstractDataFrame, or GroupedDataFrame\ni... : keyword arguments defining new columns or keys\n\nReturns\n\n::DataFrame\n\nInputs to @transform! can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, (:y = f(:x)), or as a series of keyword arguments. For example, the following are equivalent:\n\n@transform! df begin\n    :a = :x\n    :b = :y\nend\n\nand\n\n@transform!(df, :a = :x, :b = :y)\n\n@transform! uses the syntax @byrow to wrap transform!ations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@transform!(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\ntransform!(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transform!ations by row, @transform! allows @byrow at the beginning of a block of transform!ations (i.e. @byrow begin... end). All transform!ations in the block will operate by row.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> df2 = @transform!(df, :a = 2 * :A, :x = :A .+ :B)\n3×4 DataFrame\n│ Row │ A     │ B     │ a     │ x     │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 2     │ 3     │\n│ 2   │ 2     │ 1     │ 4     │ 3     │\n│ 3   │ 3     │ 2     │ 6     │ 5     │\n\njulia> df === df2\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@transform-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@transform","text":"@transform(d, i...)\n\nAdd additional columns or keys based on keyword arguments.\n\nArguments\n\nd : an AbstractDataFrame, or GroupedDataFrame\ni... : keyword arguments defining new columns or keys\n\nReturns\n\n::AbstractDataFrame or ::GroupedDataFrame\n\nInputs to @transform can come in two formats: a begin ... end block, in which case each line in the block is a separate transformation, (:y = f(:x)), or as a series of keyword arguments. For example, the following are equivalent:\n\n@transform df begin\n    :a = :x\n    :b = :y\nend\n\nand\n\n@transform(df, :a = :x, :b = :y)\n\n@transform uses the syntax @byrow to wrap transformations in the ByRow function wrapper from DataFrames, apply a function row-wise, similar to broadcasting. For example, the call\n\n@transform(df, @byrow :y = :x == 1 ? true : false)\n\nbecomes\n\ntransform(df, :x => ByRow(x -> x == 1 ? true : false) => :y)\n\na transformation which cannot be conveniently expressed using broadcasting.\n\nTo avoid writing @byrow multiple times when performing multiple transformations by row, @transform allows @byrow at the beginning of a block of transformations (i.e. @byrow begin... end). All transformations in the block will operate by row.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> @transform df begin\n           :a = 2 * :A\n           :x = :A .+ :B\n       end\n3×4 DataFrame\n Row │ A      B      a      x\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      2      3\n   2 │     2      1      4      3\n   3 │     3      2      6      5\n\njulia> @transform df @byrow :z = :A * :B\n3×3 DataFrame\n Row │ A      B      z\n     │ Int64  Int64  Int64\n─────┼─────────────────────\n   1 │     1      2      2\n   2 │     2      1      2\n   3 │     3      2      6\n\njulia> @transform df @byrow begin\n           :x = :A * :B\n           :y = :A == 1 ? 100 : 200\n       end\n\n3×4 DataFrame\n Row │ A      B      x      y\n     │ Int64  Int64  Int64  Int64\n─────┼────────────────────────────\n   1 │     1      2      2    100\n   2 │     2      1      2    200\n   3 │     3      2      6    200\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@where-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@where","text":"@subset(x, args...)\n\nDeprecated version of @subset, see ?@subset for details.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@with-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@with","text":"@with(d, expr)\n\n@with allows DataFrame columns keys to be referenced as symbols.\n\nArguments\n\nd : an AbstractDataFrame type\nexpr : the expression to evaluate in d\n\nDetails\n\n@with works by parsing the expression body for all columns indicated by symbols (e.g. :colA). Then, a function is created that wraps the body and passes the columns as function arguments. This function is then called. Operations are efficient because:\n\nA pseudo-anonymous function is defined, so types are stable.\nColumns are passed as references, eliminating DataFrame indexing.\n\nThe following\n\n@with(d, :a .+ :b .+ 1)\n\nbecomes\n\ntempfun(a, b) = a .+ b .+ 1\ntempfun(d[!, :a], d[!, :b])\n\nIf an expression is wrapped in ^(expr), expr gets passed through untouched. If an expression is wrapped in  $(expr), the column is referenced by the variable expr rather than a symbol.\n\nIf the expression provide to @with begins with @byrow, the function created by the @with block is broadcasted along the columns of the data frame.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> y = 3;\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> x = [2, 1, 0];\n\njulia> @with(df, :y .+ 1)\n3-element Array{Int64,1}:\n 3\n 2\n 3\n\njulia> @with(df, :x + x)\n3-element Array{Int64,1}:\n 3\n 3\n 3\n\njulia> @with df begin\n            res = 0.0\n            for i in 1:length(:x)\n                res += :x[i] * :y[i]\n            end\n            res\n        end\n10.0\n\njulia> @with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> colref = :x;\n\njulia> @with(df, :y + $colref) # Equivalent to df[!, :y] + df[!, colref]\n3-element Array{Int64,1}:\n 3\n 3\n 5\n\njulia> @with df @byrow :x * :y\n3-element Vector{Int64}:\n 2\n 2\n 6\n\n\nnote: Note\n@with creates a function, so the scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.\n\n\n\n\n\n","category":"macro"}]
}
