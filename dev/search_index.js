var documenterSearchIndex = {"docs":
[{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Metaprogramming tools for DataFrames.jl objects to provide more convenient syntax.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFrames.jl has the functions select, transform, and combine, as well as the in-place select! and transform! for manipulating data frames. DataFramesMeta provides the macros  @select, @transform, @combine, @select!, and @transform! to mirror these functions with  more convenient syntax. Inspired by dplyr in R  and LINQ in C#. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In addition, DataFramesMeta provides ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@orderby, for sorting data frames\n@where, for keeping rows of a DataFrame matching a given condition\n@by, for grouping and combining a data frame in a single step\n@with, for working with the columns of a data frame with high performance and  convenient syntax\n@eachrow, for looping through rows in data frame, again with high performance and  convenient syntax. \n@linq, for piping the above macros together, similar to magrittr's %>% in R. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See below the convenience of DataFramesMeta compared to DataFrames.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(a = [1, 2], b = [3, 4]);\n\n# With DataFrames\ntransform(df, [:a, :b] => ((a, b) -> a .* b .+ first(a) .- sum(b)) => :c);\n\n# With DataFramesMeta\n@transform(df, c = :a .* :b .+ first(:a) .- sum(:b))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To reference columns inside DataFramesMeta macros, use Symbols. For example, use :x to refer to the column df.x. To use a variable varname representing a Symbol to refer to  a column, use the syntax cols(varname). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Use passmissing  to propagate missing values more easily. See ?passmissing for  details. passmissing is defined in Missings.jl but exported by DataFramesMeta for convenience. ","category":"page"},{"location":"#Provided-macros","page":"Introduction","title":"Provided macros","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nNewer versions of DataFrames.jl support the operators Between, All, Cols, and Not when selecting and transforming columns. DataFramesMeta does not currently support this syntax. ","category":"page"},{"location":"#@select-and-@select!","page":"Introduction","title":"@select and @select!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Column selections and transformations. Only newly created columns are kept.  Operates on both a DataFrame and a GroupedDataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@select returns a new data frame with newly allocated columns, while @select! mutates the original data frame and returns it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When given a GroupedDataFrame, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@select(df, :x, :y)\n@select(df, x2 = 2 * :x, :y)\n@select(gd, x2 = 2 .* :y .* first(:y))\n@select!(df, :x, :y)\n@select!(df, x = 2 * :x, :y)\n@select!(gd, y = 2 .* :y .* first(:y))","category":"page"},{"location":"#@transform-and-@transform!","page":"Introduction","title":"@transform and @transform!","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Add additional columns based on keyword arguments. Operates on both a  DataFrame and a GroupedDataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform returns a new data frame with newly allocated columns, while @transform! mutates the original data frame and returns it.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When given a GroupedDataFrame, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@transform(df, :x, :y)\n@transform(df, x2 = 2 * :x, :y)\n@transform(gd, x2 = 2 .* :y .* first(:y))\n@transform!(df, :x, :y)\n@transform!(df, x = 2 * :x, :y)\n@transform!(gd, y = 2 .* :y .* first(:y))","category":"page"},{"location":"#@where","page":"Introduction","title":"@where","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Select row subsets. Operates on both a DataFrame and a GroupedDataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\noutside_var = 1;\n@where(df, :x .> 1)\n@where(df, :x .> outside_var)\n@where(df, :x .> outside_var, :y .< 102)  # the two expressions are \"and-ed\"\n@where(gd, :x .> mean(:x))","category":"page"},{"location":"#@combine","page":"Introduction","title":"@combine","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Summarize, or collapse, a grouped data frame by performing transformations at the group level and  collecting the result into a single data frame. Also works on a DataFrame, which  acts like a GroupedDataFrame with one group. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Examples:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@combine(gd, x2 = sum(:y))\n@combine(gd, x2 = :y .- sum(:y))\n@combine(gd, (n1 = sum(:y), n2 = first(:y)))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Requires a DataFrame or GroupedDataFrame as the first argument, unlike  combine from DataFrames.jl. For instance, @combine((a = sum(:x), b = sum(:y)), gd)  will fail because @combine requires a GroupedDataFrame or a DataFrame  as the first argument. The following, however, will work.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\ngd = groupby(df, :x);\n@combine(gd, (a = sum(:x), b = sum(:y)))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For arguments which return a table-like object, such as (a = sum(:x), b = sum(:y)), above, @combine only allows one argument and it must be the second positional argument.  Consider the call ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@combine(gd, (a = sum(:x), b = sum(:y)), c = first(:x))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"the above will fail because @combine does not accept a \"keyword argument\"-style column  creation after a \"return a table\"-style column creation call. ","category":"page"},{"location":"#@orderby","page":"Introduction","title":"@orderby","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Sort rows in a DataFrame by values in one of several columns or a  transformation of columns. Only operates on DataFrames and not GroupedDataFrames. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\n@orderby(df, -1 .* :x)\n@orderby(df, :x, :y .- mean(:y))","category":"page"},{"location":"#@with","page":"Introduction","title":"@with","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"@with creates a scope in which all symbols that appear are aliases for the columns in a DataFrame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = 1:3, y = [2, 1, 2])\nx = [2, 1, 0]\n\n@with(df, :y .+ 1)\n@with(df, :x + x)  # the two x's are different\n\nx = @with df begin\n    res = 0.0\n    for i in 1:length(:x)\n        res += :x[i] * :y[i]\n    end\n    res\nend\n\n@with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\n@with creates a function, so scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nBecause @with creates a function, be careful with the use of return. function data_transform(df; returnearly = false)\n    if returnearly\n        @with df begin \n            z = :x + :y\n            return z\n        end\n    else \n        return [1, 2, 3]\n    end\n\n    return [4, 5, 6]\nendThe above function will return [4, 5, 6] because the return inside the @with applies to the anonymous function created by @with. Given that @eachrow (below) is implemented with @with, the same caveat applies to  @eachrow blocks. ","category":"page"},{"location":"#@eachrow","page":"Introduction","title":"@eachrow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Act on each row of a data frame. Includes support for control flow and begin end  blocks. Since the \"environment\" induced by @eachrow df is implicitly a  single row of df, one uses regular operators and comparisons instead of  their elementwise counterparts as in @with. Does not change the input data  frame argument.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\ndf2 = @eachrow df begin \n    :A = :B + 1\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow introduces a function scope, so a let block is required here to create  a scope to allow assignment of variables within @eachrow. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\nlet x = 0.0\n    @eachrow df begin\n        if :A < :B\n            x += :B * :C\n        end\n    end\n    x\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow also supports special syntax for allocating new columns to make @eachrow more useful for data transformations. The syntax @newcol x::Vector{Int} allocates a new column :x with an Vector container with eltype Int. Here is an example where two new columns are added:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\ndf2 = @eachrow df begin\n    @newcol colX::Vector{Float64}\n    @newcol colY::Vector{Union{Int,Missing}}\n    :colX = :B == 2 ? pi * :A : :B\n    if :A > 1\n        :colY = :A * :B\n    else\n        :colY = Missing\n    end\nend","category":"page"},{"location":"#Working-with-column-names-programmatically-with-cols","page":"Introduction","title":"Working with column names programmatically with cols","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFramesMeta provides the special syntax cols for referring to  columns in a data frame via a Symbol, string, or column position as either a literal or a variable. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n\nnameA = :A\ndf2 = @transform(df, C = :B - cols(nameA))\n\nnameA_string = \"A\"\ndf3 = @transform(df, C = :B - cols(nameA_string))\n\nnameB = \"B\"\ndf4 = @eachrow df begin \n    :A = cols(nameB)\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"cols can also be used to create new columns in a data frame. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n\nnewcol = \"C\"\n@select(df, cols(newcol) = :A + :B)\n\n@by(df, :B, cols(\"A complicated\" * \" new name\") = first(:A))\n\nnameC = \"C\"\ndf3 = @eachrow df begin \n    @newcol cols(nameC)::Vector{Int}\n    cols(nameC) = :A\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DataFramesMeta macros do not allow mixing of integer column references with references  of other types. This means @transform(df, y = :A + cols(2)), attempting to add the columns  df[!, :A] and df[!, 2], will fail. This is because in DataFrames, the command ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:A, 2] => (+) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will fail, as DataFrames requires the \"source\" column identifiers in a  source => fun => dest pair to all have the same type. DataFramesMeta adds one exception to this rule. Symbols and strings are allowed to be mixed inside DataFramesMeta macros.  Consequently, ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@transform(df, y = :A + cols(\"B\"))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will not error even though ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"transform(df, [:A, \"B\"] => (+) => :y)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"will error in DataFrames. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For consistency, this restriction in the input column types also applies to @with and @eachrow. You cannot mix integer column references with Symbol or string column  references in @with and @eachrow in any part of the expression, but you can mix  Symbols and strings. The following will fail:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(A = 1:3, B = [2, 1, 2])\n@eachrow df begin \n    :A = cols(2)\nend\n\n@with df begin \n    cols(1) + cols(\"A\")\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"while the following will work without error","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@eachrow df begin \n    cols(1) = cols(2)\nend\n\n@with df begin \n    cols(1) + cols(2)\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that cols is not a standard Julia function. It is only used to modify the  way that macros in DataFramesMeta escape arguments and has no behavior of its own  outside of DataFramesMeta macros.","category":"page"},{"location":"#Working-with-Symbols-without-referring-to-columns","page":"Introduction","title":"Working with Symbols without referring to columns","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To refer to Symbols without aliasing the column in a data frame, use ^. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);\n@select(df, :x2 = :x, :x3 = ^(:x))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This rule applies to all DataFramesMeta macros.","category":"page"},{"location":"#Comparison-with-dplyr-and-LINQ","page":"Introduction","title":"Comparison with dplyr and LINQ","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A number of functions for operations on DataFrames have been defined. Here is a table of equivalents for Hadley's dplyr and common LINQ functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia             dplyr            LINQ\n---------------------------------------------\n@where            filter           Where\n@transform        mutate           Select (?)\n@by                                GroupBy\ngroupby           group_by         GroupBy\n@combine          summarise/do\n@orderby          arrange          OrderBy\n@select           select           Select","category":"page"},{"location":"#@linq-and-other-chaining-macros","page":"Introduction","title":"@linq and other chaining macros","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There is also a @linq macro that supports chaining and all of the functionality defined in other macros. Here is an example of @linq:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"df = DataFrame(a = repeat(1:5, outer = 20),\n               b = repeat([\"a\", \"b\", \"c\", \"d\"], inner = 25),\n               x = repeat(1:20, inner = 5))\n\nx_thread = @linq df |>\n    transform(y = 10 * :x) |>\n    where(:a .> 2) |>\n    by(:b, meanX = mean(:x), meanY = mean(:y)) |>\n    orderby(:meanX) |>\n    select(:meanX, :meanY, var = :b)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Relative to the use of individual macros, chaining looks cleaner and more obvious with less noise from @ symbols. This approach also avoids filling up the limited macro name space. The main downside is that more magic happens under the hood.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Alternatively you can use Chain.jl, which exports the @chain macro. With Chain.jl, there is no need for |> and the result of the previous expression is  assumed to be the first argument of the current call, unless otherwise specified  with _.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Chain, Statistics\n\ndf = DataFrame(a = repeat(1:5, outer = 20),\n               b = repeat([\"a\", \"b\", \"c\", \"d\"], inner = 25),\n               x = repeat(1:20, inner = 5))\n\nx_thread = @chain df begin\n    @transform(y = 10 * :x)\n    @where(:a .> 2)\n    @by(:b, meanX = mean(:x), meanY = mean(:y))\n    @orderby(:meanX)\n    @select(:meanX, :meanY, var = :b)\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Another alternative is Pipe.jl which exports the @pipe macro for piping.  The piping mechanism in Pipe requires explicit specification of the piped object via _ instead of assuming it is the first argument to the next function. The Pipe.jl equivalent of the above is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pipe, Statistics\n\ndf = DataFrame(a = repeat(1:5, outer = 20),\n               b = repeat([\"a\", \"b\", \"c\", \"d\"], inner = 25),\n               x = repeat(1:20, inner = 5))\n\nx_thread = @pipe df |>\n    @transform(_, y = 10 * :x) |>\n    @where(_, :a .> 2) |>\n    @by(_, :b, meanX = mean(:x), meanY = mean(:y)) |>\n    @orderby(_, :meanX) |>\n    @select(_, :meanX, :meanY, var = :b)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"api/api.md\"]\nDepth = 3","category":"page"},{"location":"api/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/api/","page":"API","title":"API","text":"Modules = [DataFramesMeta]","category":"page"},{"location":"api/api/#DataFramesMeta.get_source_fun-Tuple{Any}","page":"API","title":"DataFramesMeta.get_source_fun","text":"get_source_fun(function_expr)\n\nGiven an expression that may contain QuoteNodes (:x) and items wrapped in cols, return a function that is equivalent to that expression where the QuoteNodes and cols items are the inputs to the function.\n\nFor fast compilation get_source_fun returns the name of a called function where possible.\n\nf(:x, :y) will return f\nf.(:x, :y) will return ByRow(f)\n:x .+ :y will return .+\n\nget_source_fun also returns an expression representing the vector of inputs that will be used as the src in the src => fun => dest call later on.\n\nExamples\n\njulia> using MacroTools\n\njulia> ex = :(:x + :y)\n\njulia> DataFramesMeta.getsourcefun(ex) (:(DataFramesMeta.makesourceconcrete([:x, :y])), :+)\n\njulia> ex = quote            :x .+ 1 .* :y        end |> MacroTools.prettify\n\njulia> src, fun = DataFramesMeta.getsourcefun(ex);\n\njulia> MacroTools.prettify(fun) :((mammoth, goat)->mammoth .+ 1 .* goat)\n\n\n\n\n\n","category":"method"},{"location":"api/api/#DataFramesMeta.@based_on-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@based_on","text":"@based_on(d, args...)\n\nDeprecated version of @combine, see: @combine\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@by-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@by","text":"@by(d::AbstractDataFrame, cols, e...)\n\nSplit-apply-combine in one step.\n\nArguments\n\nd : an AbstractDataFrame\ncols : a column indicator (Symbol, Int, Vector{Symbol}, etc.)\ne :  keyword arguments specifying new columns in terms of column groupings\n\nReturns\n\n::DataFrame\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(\n            a = repeat(1:4, outer = 2),\n            b = repeat(2:-1:1, outer = 4),\n            c = 1:8);\n\njulia> @by(df, :a, d = sum(:c))\n4×2 DataFrame\n│ Row │ a     │ d     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> @by(df, :a, d = 2 * :c)\n8×2 DataFrame\n│ Row │ a     │ d     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 2     │\n│ 2   │ 1     │ 10    │\n│ 3   │ 2     │ 4     │\n│ 4   │ 2     │ 12    │\n│ 5   │ 3     │ 6     │\n│ 6   │ 3     │ 14    │\n│ 7   │ 4     │ 8     │\n│ 8   │ 4     │ 16    │\n\njulia> @by(df, :a, c_sum = sum(:c), c_mean = mean(:c))\n4×3 DataFrame\n│ Row │ a     │ c_sum │ c_mean  │\n│     │ Int64 │ Int64 │ Float64 │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 1     │ 6     │ 3.0     │\n│ 2   │ 2     │ 8     │ 4.0     │\n│ 3   │ 3     │ 10    │ 5.0     │\n│ 4   │ 4     │ 12    │ 6.0     │\n\njulia> @by(df, :a, c = :c, c_mean = mean(:c))\n8×3 DataFrame\n│ Row │ a     │ c     │ c_mean  │\n│     │ Int64 │ Int64 │ Float64 │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 1     │ 1     │ 3.0     │\n│ 2   │ 1     │ 5     │ 3.0     │\n│ 3   │ 2     │ 2     │ 4.0     │\n│ 4   │ 2     │ 6     │ 4.0     │\n│ 5   │ 3     │ 3     │ 5.0     │\n│ 6   │ 3     │ 7     │ 5.0     │\n│ 7   │ 4     │ 4     │ 6.0     │\n│ 8   │ 4     │ 8     │ 6.0     │\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@byrow!-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@byrow!","text":"@byrow!(d, expr)\n\nDeprecated version of @eachrow, see: @eachrow\n\nActs the exact same way. It does not change the input argument d in-place.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@byrow-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@byrow","text":"@byrow(d, expr)\n\nDeprecated version of @eachrow, see: @eachrow\n\nActs the exact same way.\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@col-Tuple{Any}","page":"API","title":"DataFramesMeta.@col","text":"@col(kw)\n\n@col transforms an expression of the form z = :x + :y into it's equivalent in DataFrames's source => fun => destination syntax.\n\nDetails\n\nParsing follows the same convention as other DataFramesMeta.jl macros, such as @with. All terms in the expression that are Symbols are treated as columns in the data frame, except Symbols wrapped in ^. To use a variable representing a column name, wrap the variable in cols.\n\n@col constructs an anonymous function fun based on the given expression. It then creates a source => fun => destination pair that is suitable for the select, transform, and combine functions in DataFrames.jl.\n\nExamples\n\njulia> @col z = :x + :y\n[:x, :y] => (##595 => :z)\n\nIn the above example, ##595 is an anonymous function equivalent to the following\n\n(_x, _y) -> _x + _y\n\njulia> using DataFramesMeta;\n\njulia> df = DataFrame(x = [1, 2], y = [3, 4]);\n\njulia> import DataFramesMeta: @col;\n\njulia> DataFrames.transform(df, @col z = :x .* :y)\n2×3 DataFrame\n│ Row │ x     │ y     │ z     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 3     │ 3     │\n│ 2   │ 2     │ 4     │ 8     │\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@combine-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@combine","text":"@combine(x, args...)\n\nSummarize a grouping operation\n\nArguments\n\nx : a GroupedDataFrame or AbstractDataFrame\nargs... : keyword arguments defining new columns\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> d = DataFrame(\n            n = 1:20,\n            x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(d, :x);\n\njulia> @combine(g, nsum = sum(:n))\n3×2 DataFrame\n│ Row │ x     │ nsum  │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 3     │ 27    │\n│ 2   │ 1     │ 99    │\n│ 3   │ 2     │ 84    │\n\njulia> @combine(g, x2 = 2 * :x, nsum = sum(:n))\n20×3 DataFrame\n│ Row │ x     │ x2    │ nsum  │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 6     │ 27    │\n│ 2   │ 3     │ 6     │ 27    │\n│ 3   │ 3     │ 6     │ 27    │\n│ 4   │ 3     │ 6     │ 27    │\n│ 5   │ 3     │ 6     │ 27    │\n│ 6   │ 1     │ 2     │ 99    │\n│ 7   │ 1     │ 2     │ 99    │\n⋮\n│ 13  │ 1     │ 2     │ 99    │\n│ 14  │ 1     │ 2     │ 99    │\n│ 15  │ 2     │ 4     │ 84    │\n│ 16  │ 2     │ 4     │ 84    │\n│ 17  │ 2     │ 4     │ 84    │\n│ 18  │ 2     │ 4     │ 84    │\n│ 19  │ 2     │ 4     │ 84    │\n│ 20  │ 2     │ 4     │ 84    │\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@eachrow-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@eachrow","text":"@eachrow(d, body)\n\nAct on each row of a data frame, similar to\n\nfor row in eachrow(df)\n    ...\nend\n\nIncludes support for control flow and begin end blocks. Since the \"environment\" induced by @eachrow df is implicitly a single row of df, use regular operators and comparisons instead of their elementwise counterparts as in @with. Note that the scope within @eachrow is a hard scope.\n\neachrow also supports special syntax for allocating new columns. The syntax @newcol x::Vector{Int} allocates a new column :x with an Vector container with eltype Int.This feature makes it easier to use eachrow for data transformations. _N is introduced to represent the length of the dataframe, _D represents the dataframe including added columns, and row represents the index of the current row.\n\nChanges to the rows do not affect d but instead a freshly allocated data frame is returned by @eachrow. Also note that the returned data frame does not share columns with d.\n\nLike with @transform, @eachrow supports the use of cols to work with column names stored as variables. Using cols with a multi-column selector, such as a Vector of Symbols, is currently unsupported.\n\nArguments\n\nd : an AbstractDataFrame\nexpr : expression operated on row by row\n\nReturns\n\nThe modified AbstractDataFrame.\n\nExamples\n\njulia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> let x = 0\n            @eachrow df begin\n                if :A + :B == 3\n                    x += 1\n                end\n            end  #  This doesn't work without the let\n            x\n        end\n2\n\njulia> @eachrow df begin\n            if :A > :B\n                :A = 0\n            end\n        end\n3×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 2     │\n│ 2   │ 0     │ 1     │\n│ 3   │ 0     │ 2     │\n\njulia> df2 = @eachrow df begin\n           @newcol colX::Vector{Float64}\n           :colX = :B == 2 ? pi * :A : :B\n       end\n3×3 DataFrame\n│ Row │ A     │ B     │ colX    │\n│     │ Int64 │ Int64 │ Float64 │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 1     │ 2     │ 3.14159 │\n│ 2   │ 2     │ 1     │ 1.0     │\n│ 3   │ 3     │ 2     │ 9.42478 │\n\njulia> varA = :A; varB = :B;\n\njulia> df2 = @eachrow df begin\n           @newcol colX::Vector{Float64}\n           :colX = cols(varB) == 2 ? pi * cols(varA) : cols(varB)\n       end\n3×3 DataFrame\n│ Row │ A     │ B     │ colX    │\n│     │ Int64 │ Int64 │ Float64 │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 1     │ 2     │ 3.14159 │\n│ 2   │ 2     │ 1     │ 1.0     │\n│ 3   │ 3     │ 2     │ 9.42478 │\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@linq-Tuple{Any}","page":"API","title":"DataFramesMeta.@linq","text":"@linq df ...\n\nGeneral macro that creates a mini DSL for chaining and macro calls.\n\nDetails\n\nThe following embedded function calls are equivalent to their macro version:\n\nwith\nwhere\nselect\ntransform\nby\ngroupby\norderby\ncombine\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(\n            a = repeat(1:4, outer = 2),\n            b = repeat(2:-1:1, outer = 4),\n            x = 1:8);\n\njulia> x1 = @linq transform(where(df, :a .> 2, :b .!= \"c\"), y = 10 .* :x);\n\njulia> x1 = @linq by(x1, :b, meanX = mean(:x), meanY = mean(:y));\n\njulia> @linq select(orderby(x1, :b, -:meanX), var = :b, :meanX, :meanY)\n2×3 DataFrame\n│ Row │ var   │ meanX   │ meanY   │\n│     │ Int64 │ Float64 │ Float64 │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ 6.0     │ 60.0    │\n│ 2   │ 2     │ 5.0     │ 50.0    │\n\njulia> @linq df |>\n           transform(y = 10 .* :x) |>\n           where(:a .> 2) |>\n           by(:b, meanX = mean(:x), meanY = mean(:y)) |>\n           orderby(:meanX) |>\n           select(:meanX, :meanY, var = :b)\n2×3 DataFrame\n│ Row │ meanX   │ meanY   │ var   │\n│     │ Float64 │ Float64 │ Int64 │\n├─────┼─────────┼─────────┼───────┤\n│ 1   │ 5.0     │ 50.0    │ 2     │\n│ 2   │ 6.0     │ 60.0    │ 1     │\n\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@orderby-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@orderby","text":"@orderby(d, i...)\n\nSort rows by values in one of several columns or a transformation of columns. Always returns a fresh DataFrame. Does not accept a GroupedDataFrame.\n\nWhen given a DataFrame, @orderby applies the transformation given by its arguments (but does not create new columns) and sorts the given DataFrame on the result, returning a new DataFrame.\n\nArguments\n\nd : an AbstractDataFrame\ni... : expression for sorting\n\nExamples\n\n```jldoctest julia> using DataFramesMeta, Statistics\n\njulia> d = DataFrame(x = [3, 3, 3, 2, 1, 1, 1, 2, 1, 1], n = 1:10,                      c = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]);\n\njulia> @orderby(d, -1 .* :n) 10×3 DataFrame  Row │ x      n      c      │ Int64  Int64  String ─────┼──────────────────────    1 │     1     10  j    2 │     1      9  i    3 │     2      8  h    4 │     1      7  g    5 │     1      6  f    6 │     1      5  e    7 │     2      4  d    8 │     3      3  c    9 │     3      2  b   10 │     3      1  a\n\njulia> @orderby(d, sortperm(:c, rev = true)) 10×3 DataFrame  Row │ x      n      c      │ Int64  Int64  String ─────┼──────────────────────    1 │     1     10  j    2 │     1      9  i    3 │     2      8  h    4 │     1      7  g    5 │     1      6  f    6 │     1      5  e    7 │     2      4  d    8 │     3      3  c    9 │     3      2  b   10 │     3      1  a\n\njulia> @orderby(d, :x, abs.(:n .- mean(:n))) 10×3 DataFrame  Row │ x      n      c      │ Int64  Int64  String ─────┼──────────────────────    1 │     1      5  e    2 │     1      6  f    3 │     1      7  g    4 │     1      9  i    5 │     1     10  j    6 │     2      4  d    7 │     2      8  h    8 │     3      3  c    9 │     3      2  b   10 │     3      1  a\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@select!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@select!","text":"@select!(d, e...)\n\nMutate d in-place to retain only columns or transformations specified by e and return it. No copies of existing columns are made.\n\nArguments\n\nd : an AbstractDataFrame\ne :  keyword arguments specifying new columns in terms of existing columns or symbols to specify existing columns\n\nReturns\n\n::DataFrame\n\nExamples\n\njulia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> df2 = @select!(df, :c, :a)\n8×2 DataFrame\n│ Row │ c     │ a     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 4     │ 4     │\n│ 5   │ 5     │ 1     │\n│ 6   │ 6     │ 2     │\n│ 7   │ 7     │ 3     │\n│ 8   │ 8     │ 4     │\n\njulia> df === df2\ntrue\n\n\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> df2 = @select!(df, :c, x = :b + :c)\n8×2 DataFrame\n│ Row │ c     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 3     │\n│ 3   │ 3     │ 5     │\n│ 4   │ 4     │ 5     │\n│ 5   │ 5     │ 7     │\n│ 6   │ 6     │ 7     │\n│ 7   │ 7     │ 9     │\n│ 8   │ 8     │ 9     │\n\njulia> df === df2\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@select-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@select","text":"@select(d, e...)\n\nSelect and transform columns.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ne :  keyword arguments specifying new columns in terms of existing columns or symbols to specify existing columns\n\nReturns\n\n::AbstractDataFrame\n\nExamples\n\njulia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(a = repeat(1:4, outer = 2), b = repeat(2:-1:1, outer = 4), c = 1:8);\n\njulia> @select(df, :c, :a)\n8×2 DataFrame\n│ Row │ c     │ a     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 4     │ 4     │\n│ 5   │ 5     │ 1     │\n│ 6   │ 6     │ 2     │\n│ 7   │ 7     │ 3     │\n│ 8   │ 8     │ 4     │\n\njulia> @select(df, :c, x = :b + :c)\n8×2 DataFrame\n│ Row │ c     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 3     │\n│ 3   │ 3     │ 5     │\n│ 4   │ 4     │ 5     │\n│ 5   │ 5     │ 7     │\n│ 6   │ 6     │ 7     │\n│ 7   │ 7     │ 9     │\n│ 8   │ 8     │ 9     │\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@transform!-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@transform!","text":"@transform!(d, i...)\n\nMutate d inplace to add additional columns or keys based on keyword arguments and return it. No copies of existing columns are made.\n\nArguments\n\nd : an AbstractDataFrame, or GroupedDataFrame\ni... : keyword arguments defining new columns or keys\n\nReturns\n\n::DataFrame\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> df2 = @transform!(df, a = 2 * :A, x = :A .+ :B)\n3×4 DataFrame\n│ Row │ A     │ B     │ a     │ x     │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 2     │ 3     │\n│ 2   │ 2     │ 1     │ 4     │ 3     │\n│ 3   │ 3     │ 2     │ 6     │ 5     │\n\njulia> df === df2\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@transform-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@transform","text":"@transform(d, i...)\n\nAdd additional columns or keys based on keyword arguments.\n\nArguments\n\nd : an AbstractDataFrame, or GroupedDataFrame\ni... : keyword arguments defining new columns or keys\n\nReturns\n\n::AbstractDataFrame or ::GroupedDataFrame\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> df = DataFrame(A = 1:3, B = [2, 1, 2]);\n\njulia> @transform(df, a = 2 * :A, x = :A .+ :B)\n3×4 DataFrame\n│ Row │ A     │ B     │ a     │ x     │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 2     │ 3     │\n│ 2   │ 2     │ 1     │ 4     │ 3     │\n│ 3   │ 3     │ 2     │ 6     │ 5     │\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@where-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"DataFramesMeta.@where","text":"@where(d, i...)\n\nSelect row subsets in AbstractDataFrames and GroupedDataFrames.\n\nArguments\n\nd : an AbstractDataFrame or GroupedDataFrame\ni... : expression for selecting rows\n\nMultiple i expressions are \"and-ed\" together.\n\nIf given a GroupedDataFrame, @where applies transformations by group, and returns a fresh DataFrame containing the rows for which the generated values are all true.\n\nnote: Note\n@where treats missing values as false when filtering rows. Unlike DataFrames.filter and other boolean operations with missing, @where will not error on missing values, and will only keep true values.\n\nExamples\n\njulia> using DataFramesMeta, Statistics\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> globalvar = [2, 1, 0];\n\njulia> @where(df, :x .> 1)\n2×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 2     │ 1     │\n│ 2   │ 3     │ 2     │\n\njulia> @where(df, :x .> globalvar)\n2×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 2     │ 1     │\n│ 2   │ 3     │ 2     │\n\njulia> @where(df, :x .> globalvar, :y .== 3)\n0×2 DataFrame\n\njulia> d = DataFrame(n = 1:20, x = [3, 3, 3, 3, 1, 1, 1, 2, 1, 1,\n                                    2, 1, 1, 2, 2, 2, 3, 1, 1, 2]);\n\njulia> g = groupby(d, :x);\n\njulia> @where(g, :n .> mean(:n))\n8×2 DataFrame\n│ Row │ n     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 12    │ 1     │\n│ 2   │ 13    │ 1     │\n│ 3   │ 15    │ 2     │\n│ 4   │ 16    │ 2     │\n│ 5   │ 17    │ 3     │\n│ 6   │ 18    │ 1     │\n│ 7   │ 19    │ 1     │\n│ 8   │ 20    │ 2     │\n\njulia> @where(g, :n .== first(:n))\n3×2 DataFrame\n│ Row │ n     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 5     │ 1     │\n│ 3   │ 8     │ 2     │\n\njulia> d = DataFrame(a = [1, 2, missing], b = [\"x\", \"y\", missing]);\n\njulia> @where(d, :a .== 1)\n1×2 DataFrame\n│ Row │ a      │ b       │\n│     │ Int64? │ String? │\n├─────┼────────┼─────────┤\n│ 1   │ 1      │ x       │\n\n\n\n\n\n","category":"macro"},{"location":"api/api/#DataFramesMeta.@with-Tuple{Any,Any}","page":"API","title":"DataFramesMeta.@with","text":"@with(d, expr)\n\n@with allows DataFrame columns keys to be referenced as symbols.\n\nArguments\n\nd : an AbstractDataFrame type\nexpr : the expression to evaluate in d\n\nDetails\n\n@with works by parsing the expression body for all columns indicated by symbols (e.g. :colA). Then, a function is created that wraps the body and passes the columns as function arguments. This function is then called. Operations are efficient because:\n\nA pseudo-anonymous function is defined, so types are stable.\nColumns are passed as references, eliminating DataFrame indexing.\n\nThe following\n\n@with(d, :a .+ :b .+ 1)\n\nbecomes\n\ntempfun(a, b) = a .+ b .+ 1\ntempfun(d[!, :a], d[!, :b])\n\nIf an expression is wrapped in ^(expr), expr gets passed through untouched. If an expression is wrapped in  cols(expr), the column is referenced by the variable expr rather than a symbol.\n\nExamples\n\njulia> using DataFramesMeta\n\njulia> y = 3;\n\njulia> df = DataFrame(x = 1:3, y = [2, 1, 2]);\n\njulia> x = [2, 1, 0];\n\njulia> @with(df, :y .+ 1)\n3-element Array{Int64,1}:\n 3\n 2\n 3\n\njulia> @with(df, :x + x)\n3-element Array{Int64,1}:\n 3\n 3\n 3\n\njulia> @with df begin\n            res = 0.0\n            for i in 1:length(:x)\n                res += :x[i] * :y[i]\n            end\n            res\n        end\n10.0\n\njulia> @with(df, df[:x .> 1, ^(:y)]) # The ^ means leave the :y alone\n2-element Array{Int64,1}:\n 1\n 2\n\njulia> colref = :x;\n\njulia> @with(df, :y + cols(colref)) # Equivalent to df[!, :y] + df[!, colref]\n3-element Array{Int64,1}:\n 3\n 3\n 5\n\nnote: Note\n@with creates a function, so the scope within @with is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the global keyword. If the parent scope is a local scope (inside a function or let block for example), the global keyword is not needed to assign to that parent scope.\n\n\n\n\n\n","category":"macro"}]
}
