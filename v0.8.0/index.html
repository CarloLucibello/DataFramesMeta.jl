<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · DataFramesMeta Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://juliadata.github.io/DataFramesMeta.jl/stable/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DataFramesMeta Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Provided-macros"><span>Provided macros</span></a></li><li><a class="tocitem" href="#@select-and-@select!"><span><code>@select</code> and <code>@select!</code></span></a></li><li><a class="tocitem" href="#@transform-and-@transform!"><span><code>@transform</code> and <code>@transform!</code></span></a></li><li><a class="tocitem" href="#@subset-and-@subset!"><span><code>@subset</code> and <code>@subset!</code></span></a></li><li><a class="tocitem" href="#@combine"><span><code>@combine</code></span></a></li><li><a class="tocitem" href="#@orderby"><span><code>@orderby</code></span></a></li><li><a class="tocitem" href="#@with"><span><code>@with</code></span></a></li><li><a class="tocitem" href="#@eachrow-and-@eachrow!"><span><code>@eachrow</code> and <code>@eachrow!</code></span></a></li><li><a class="tocitem" href="#Row-wise-transformations-with-@byrow"><span>Row-wise transformations with <code>@byrow</code></span></a></li><li><a class="tocitem" href="#Working-with-column-names-programmatically-with-cols"><span>Working with column names programmatically with <code>cols</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Working-with-Symbols-without-referring-to-columns"><span>Working with <code>Symbol</code>s without referring to columns</span></a></li><li><a class="tocitem" href="#Comparison-with-dplyr-and-LINQ"><span>Comparison with <code>dplyr</code> and LINQ</span></a></li><li><a class="tocitem" href="#Chaining-operations-together-with-@chain"><span>Chaining operations together with <code>@chain</code></span></a></li></ul></li><li><a class="tocitem" href="api/api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/DataFramesMeta.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>Metaprogramming tools for DataFrames.jl objects to provide more convenient syntax.</p><p>DataFrames.jl has the functions <code>select</code>, <code>transform</code>, and <code>combine</code>, as well as the in-place <code>select!</code> and <code>transform!</code> for manipulating data frames. DataFramesMeta provides the macros  <code>@select</code>, <code>@transform</code>, <code>@combine</code>, <code>@select!</code>, and <code>@transform!</code> to mirror these functions with  more convenient syntax. Inspired by <a href="https://dplyr.tidyverse.org/">dplyr</a> in R  and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">LINQ</a> in C#. </p><p>In addition, DataFramesMeta provides </p><ul><li><code>@orderby</code>, for sorting data frames</li><li><code>@subset</code> and <code>@subset!</code>, for keeping rows of a data frame matching a given condition</li><li><code>@by</code>, for grouping and combining a data frame in a single step</li><li><code>@with</code>, for working with the columns of a data frame with high performance and  convenient syntax</li><li><code>@eachrow</code> and <code>@eachrow!</code> for looping through rows in data frame, again with high performance and  convenient syntax. </li><li><code>@byrow</code> for applying functions to each row of a data frame (only supported inside other macros).</li><li><code>@chain</code>, from <a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a> for piping the above macros together, similar to <a href="https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html">magrittr</a>&#39;s <code>%&gt;%</code> in R. </li></ul><p>See below the convenience of DataFramesMeta compared to DataFrames.</p><pre><code class="language-julia">df = DataFrame(a = [1, 2], b = [3, 4]);

# With DataFrames
transform(df, [:a, :b] =&gt; ((a, b) -&gt; a .* b .+ first(a) .- sum(b)) =&gt; :c);

# With DataFramesMeta
@transform(df, :c = :a .* :b .+ first(:a) .- sum(:b))</code></pre><p>To reference columns inside DataFramesMeta macros, use <code>Symbol</code>s. For example, use <code>:x</code> to refer to the column <code>df.x</code>. To use a variable <code>varname</code> representing a <code>Symbol</code> to refer to  a column, use the syntax <code>cols(varname)</code>. </p><p>Use <code>passmissing</code>  to propagate <code>missing</code> values more easily. See <code>?passmissing</code> for  details. <code>passmissing</code> is defined in <a href="https://github.com/JuliaData/Missings.jl">Missings.jl</a> but exported by DataFramesMeta for convenience. </p><h1 id="Provided-macros"><a class="docs-heading-anchor" href="#Provided-macros">Provided macros</a><a id="Provided-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Provided-macros" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Newer versions of DataFrames.jl support the operators <code>Between</code>, <code>All</code>, <code>Cols</code>, and <code>Not</code> when selecting and transforming columns. DataFramesMeta does not currently support this syntax. </p></div></div><h2 id="@select-and-@select!"><a class="docs-heading-anchor" href="#@select-and-@select!"><code>@select</code> and <code>@select!</code></a><a id="@select-and-@select!-1"></a><a class="docs-heading-anchor-permalink" href="#@select-and-@select!" title="Permalink"></a></h2><p>Column selections and transformations. Only newly created columns are kept.  Operates on both a <code>DataFrame</code> and a <code>GroupedDataFrame</code>. </p><p><code>@select</code> returns a new data frame with newly allocated columns, while <code>@select!</code> mutates the original data frame and returns it.</p><p>When given a <code>GroupedDataFrame</code>, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. </p><pre><code class="language-julia">df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
gd = groupby(df, :x);
@select(df, :x, :y)
@select(df, :x2 = 2 * :x, :y)
@select(gd, :x2 = 2 .* :y .* first(:y))
@select!(df, :x, :y)
@select!(df, :x = 2 * :x, :y)
@select!(gd, :y = 2 .* :y .* first(:y))</code></pre><h2 id="@transform-and-@transform!"><a class="docs-heading-anchor" href="#@transform-and-@transform!"><code>@transform</code> and <code>@transform!</code></a><a id="@transform-and-@transform!-1"></a><a class="docs-heading-anchor-permalink" href="#@transform-and-@transform!" title="Permalink"></a></h2><p>Add additional columns based on keyword arguments. Operates on both a  <code>DataFrame</code> and a <code>GroupedDataFrame</code>. </p><p><code>@transform</code> returns a new data frame with newly allocated columns, while <code>@transform!</code> mutates the original data frame and returns it.</p><p>When given a <code>GroupedDataFrame</code>, performs a transformation by group and then  if necessary repeats the result to have as many rows as the input  data frame. </p><pre><code class="language-julia">df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
gd = groupby(df, :x);
@transform(df, :x, :y)
@transform(df, :x2 = 2 * :x, :y)
@transform(gd, :x2 = 2 .* :y .* first(:y))
@transform!(df, :x, :y)
@transform!(df, :x = 2 * :x, :y)
@transform!(gd, :y = 2 .* :y .* first(:y))</code></pre><h2 id="@subset-and-@subset!"><a class="docs-heading-anchor" href="#@subset-and-@subset!"><code>@subset</code> and <code>@subset!</code></a><a id="@subset-and-@subset!-1"></a><a class="docs-heading-anchor-permalink" href="#@subset-and-@subset!" title="Permalink"></a></h2><p>Select row subsets. Operates on both a <code>DataFrame</code> and a <code>GroupedDataFrame</code>.  <code>@subset</code> always returns a freshly-allocated data frame whereas  <code>@subset!</code> modifies the data frame in-place.</p><pre><code class="language-julia">using Statistics
df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
gd = groupby(df, :x);
outside_var = 1;
@subset(df, :x .&gt; 1)
@subset(df, :x .&gt; outside_var)
@subset(df, :x .&gt; outside_var, :y .&lt; 102)  # the two expressions are &quot;and-ed&quot;
@subset(gd, :x .&gt; mean(:x))</code></pre><h2 id="@combine"><a class="docs-heading-anchor" href="#@combine"><code>@combine</code></a><a id="@combine-1"></a><a class="docs-heading-anchor-permalink" href="#@combine" title="Permalink"></a></h2><p>Summarize, or collapse, a grouped data frame by performing transformations at the group level and  collecting the result into a single data frame. Also works on a <code>DataFrame</code>, which  acts like a <code>GroupedDataFrame</code> with one group. </p><p>Examples:</p><pre><code class="language-julia">df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
gd = groupby(df, :x);
@combine(gd, :x2 = sum(:y))
@combine(gd, :x2 = :y .- sum(:y))
@combine(gd, (n1 = sum(:y), n2 = first(:y)))</code></pre><p>Requires a <code>DataFrame</code> or <code>GroupedDataFrame</code> as the first argument, unlike  <code>combine</code> from DataFrames.jl. For instance, <code>@combine((a = sum(:x), b = sum(:y)), gd)</code>  will fail because <code>@combine</code> requires a <code>GroupedDataFrame</code> or a <code>DataFrame</code>  as the first argument. The following, however, will work.</p><pre><code class="nohighlight">df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
gd = groupby(df, :x);
@combine(gd, (a = sum(:x), b = sum(:y)))</code></pre><p>For arguments which return a table-like object, such as <code>(a = sum(:x), b = sum(:y))</code>, above, <code>@combine</code> only allows <em>one</em> argument and it must be the <em>second</em> positional argument.  Consider the call </p><pre><code class="nohighlight">@combine(gd, (a = sum(:x), b = sum(:y)), c = first(:x))</code></pre><p>the above will fail because <code>@combine</code> does not accept a &quot;keyword argument&quot;-style column  creation after a &quot;return a table&quot;-style column creation call. </p><h2 id="@orderby"><a class="docs-heading-anchor" href="#@orderby"><code>@orderby</code></a><a id="@orderby-1"></a><a class="docs-heading-anchor-permalink" href="#@orderby" title="Permalink"></a></h2><p>Sort rows in a <code>DataFrame</code> by values in one of several columns or a  transformation of columns. Only operates on <code>DataFrame</code>s and not <code>GroupedDataFrame</code>s. </p><pre><code class="language-julia">df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
@orderby(df, -1 .* :x)
@orderby(df, :x, :y .- mean(:y))</code></pre><h2 id="@with"><a class="docs-heading-anchor" href="#@with"><code>@with</code></a><a id="@with-1"></a><a class="docs-heading-anchor-permalink" href="#@with" title="Permalink"></a></h2><p><code>@with</code> creates a scope in which all symbols that appear are aliases for the columns in a DataFrame. </p><pre><code class="language-julia">df = DataFrame(x = 1:3, y = [2, 1, 2])
x = [2, 1, 0]

@with(df, :y .+ 1)
@with(df, :x + x)  # the two x&#39;s are different

x = @with df begin
    res = 0.0
    for i in 1:length(:x)
        res += :x[i] * :y[i]
    end
    res
end

@with(df, df[:x .&gt; 1, ^(:y)]) # The ^ means leave the :y alone
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@with</code> creates a function, so scope within <code>@with</code> is a local scope. Variables in the parent can be read. Writing to variables in the parent scope differs depending on the type of scope of the parent. If the parent scope is a global scope, then a variable cannot be assigned without using the <code>global</code> keyword. If the parent scope is a local scope (inside a function or let block for example), the <code>global</code> keyword is not needed to assign to that parent scope.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Because <code>@with</code> creates a function, be careful with the use of <code>return</code>. </p><pre><code class="nohighlight">function data_transform(df; returnearly = false)
    if returnearly
        @with df begin 
            z = :x + :y
            return z
        end
    else 
        return [1, 2, 3]
    end

    return [4, 5, 6]
end</code></pre><p>The above function will return <code>[4, 5, 6]</code> because the <code>return</code> inside the <code>@with</code> applies to the anonymous function created by <code>@with</code>. </p><p>Given that <code>@eachrow</code> (below) is implemented with <code>@with</code>, the same caveat applies to  <code>@eachrow</code> blocks. </p></div></div><h2 id="@eachrow-and-@eachrow!"><a class="docs-heading-anchor" href="#@eachrow-and-@eachrow!"><code>@eachrow</code> and <code>@eachrow!</code></a><a id="@eachrow-and-@eachrow!-1"></a><a class="docs-heading-anchor-permalink" href="#@eachrow-and-@eachrow!" title="Permalink"></a></h2><p>Act on each row of a data frame. Includes support for control flow and <code>begin end</code>  blocks. Since the &quot;environment&quot; induced by <code>@eachrow df</code> is implicitly a  single row of <code>df</code>, one uses regular operators and comparisons instead of  their elementwise counterparts as in <code>@with</code>. Does not change the input data  frame argument.</p><p><code>@eachrow!</code> is identical to <code>@eachrow</code> but acts on a data frame in-place, modifying the input.</p><pre><code class="language-julia">df = DataFrame(A = 1:3, B = [2, 1, 2])
df2 = @eachrow df begin 
    :A = :B + 1
end</code></pre><p><code>@eachrow</code> introduces a function scope, so a <code>let</code> block is required here to create  a scope to allow assignment of variables within <code>@eachrow</code>. </p><pre><code class="language-julia">df = DataFrame(A = 1:3, B = [2, 1, 2])
let x = 0.0
    @eachrow df begin
        if :A &lt; :B
            x += :B * :C
        end
    end
    x
end</code></pre><p><code>@eachrow</code> also supports special syntax for allocating new columns to make <code>@eachrow</code> more useful for data transformations. The syntax <code>@newcol :x::Vector{Int}</code> allocates a new column <code>:x</code> with an <code>Vector</code> container with eltype <code>Int</code>. Here is an example where two new columns are added:</p><pre><code class="language-julia">df = DataFrame(A = 1:3, B = [2, 1, 2])
df2 = @eachrow df begin
    @newcol :colX::Vector{Float64}
    @newcol :colY::Vector{Union{Int,Missing}}
    :colX = :B == 2 ? pi * :A : :B
    if :A &gt; 1
        :colY = :A * :B
    else
        :colY = missing
    end
end</code></pre><h2 id="Row-wise-transformations-with-@byrow"><a class="docs-heading-anchor" href="#Row-wise-transformations-with-@byrow">Row-wise transformations with <code>@byrow</code></a><a id="Row-wise-transformations-with-@byrow-1"></a><a class="docs-heading-anchor-permalink" href="#Row-wise-transformations-with-@byrow" title="Permalink"></a></h2><p><code>@byrow</code> provides a convenient syntax to apply operations by-row, without having to vectorize manually.  </p><p>DataFrames.jl provides the function wrapper <code>ByRow</code>. <code>ByRow(f)(x, y)</code> is roughly equivalent to <code>f.(x, y)</code>. DataFramesMeta.jl allows users  to construct expressions using <code>ByRow</code> function wrapper with the  syntax <code>@byrow</code>. </p><p><code>@byrow</code> is not a &quot;real&quot; macro and cannot be used outside of  DataFramesMeta.jl macros. However its behavior within DataFramesMeta.jl macros should be indistinguishable from externally defined macros.  Thought of as a macro <code>@byrow</code> accepts a single argument and  creates an anonymous function wrapped in <code>ByRow</code>.  For example,</p><pre><code class="language-julia">@transform(df, @byrow :y = :x == 1 ? true : false)</code></pre><p>is equivalent to</p><pre><code class="language-julia">transform(df, :x =&gt; ByRow(x -&gt; x == 1 ? true, false) =&gt; :y)</code></pre><p>The following macros accept <code>@byrow</code>:</p><ul><li><code>@transform</code> and <code>@transform!</code>, <code>@select</code>, <code>@select!</code>, and <code>@combine</code>.  <code>@byrow</code> can be used in the left hand side of expressions, e.g. <code>@select(df, @byrow z = :x * :y)</code>. </li><li><code>@subset</code>, <code>@subset!</code> and <code>@orderby</code>, with syntax of the form <code>@where(df, @byrow :x &gt; :y)</code></li><li><code>@with</code>, where the anonymous function created by <code>@with</code> is wrapped in <code>ByRow</code>, as in <code>@with(df, @byrow :x * :y)</code>.</li></ul><p>To avoid writing <code>@byrow</code> multiple times when performing multiple operations, it is allowed to use<code>@byrow</code> at the beginning of a block of  operations. All transformations in the block will operate by row.</p><pre><code class="language-julia">julia&gt; @where df @byrow begin 
           :a &gt; 1
           :b &lt; 5
       end
1×2 DataFrame
 Row │ a      b     
     │ Int64  Int64 
─────┼──────────────
   1 │     2      4</code></pre><p><code>@byrow</code> can be used inside macros which accept <code>GroupedDataFrame</code>s, however, like with <code>ByRow</code> in DataFrames.jl, when <code>@byrow</code> is used, functions do not take into account the grouping, so for example the result of <code>@transform(df, @byrow y = f(:x))</code> and  <code>@transform(groupby(df, :g), @byrow :y = f(:x))</code> is the same.</p><h2 id="Working-with-column-names-programmatically-with-cols"><a class="docs-heading-anchor" href="#Working-with-column-names-programmatically-with-cols">Working with column names programmatically with <code>cols</code></a><a id="Working-with-column-names-programmatically-with-cols-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-column-names-programmatically-with-cols" title="Permalink"></a></h2><p>DataFramesMeta provides the special syntax <code>cols</code> for referring to  columns in a data frame via a <code>Symbol</code>, string, or column position as either a literal or a variable. </p><pre><code class="language-julia">df = DataFrame(A = 1:3, B = [2, 1, 2])

nameA = :A
df2 = @transform(df, C = :B - cols(nameA))

nameA_string = &quot;A&quot;
df3 = @transform(df, C = :B - cols(nameA_string))

nameB = &quot;B&quot;
df4 = @eachrow df begin 
    :A = cols(nameB)
end</code></pre><p><code>cols</code> can also be used to create new columns in a data frame. </p><pre><code class="language-julia">df = DataFrame(A = 1:3, B = [2, 1, 2])

newcol = &quot;C&quot;
@select(df, cols(newcol) = :A + :B)

@by(df, :B, cols(&quot;A complicated&quot; * &quot; new name&quot;) = first(:A))

nameC = &quot;C&quot;
df3 = @eachrow df begin 
    @newcol cols(nameC)::Vector{Int}
    cols(nameC) = :A
end</code></pre><p>DataFramesMeta macros do not allow mixing of integer column references with references  of other types. This means <code>@transform(df, y = :A + cols(2))</code>, attempting to add the columns  <code>df[!, :A]</code> and <code>df[!, 2]</code>, will fail. This is because in DataFrames, the command </p><pre><code class="language-julia">transform(df, [:A, 2] =&gt; (+) =&gt; :y)</code></pre><p>will fail, as DataFrames requires the &quot;source&quot; column identifiers in a  <code>source =&gt; fun =&gt; dest</code> pair to all have the same type. DataFramesMeta adds one exception to this rule. <code>Symbol</code>s and strings are allowed to be mixed inside DataFramesMeta macros.  Consequently, </p><pre><code class="nohighlight">@transform(df, y = :A + cols(&quot;B&quot;))</code></pre><p>will not error even though </p><pre><code class="nohighlight">transform(df, [:A, &quot;B&quot;] =&gt; (+) =&gt; :y)</code></pre><p>will error in DataFrames. </p><p>For consistency, this restriction in the input column types also applies to <code>@with</code> and <code>@eachrow</code>. You cannot mix integer column references with <code>Symbol</code> or string column  references in <code>@with</code> and <code>@eachrow</code> in any part of the expression, but you can mix  <code>Symbol</code>s and strings. The following will fail:</p><pre><code class="language-julia">df = DataFrame(A = 1:3, B = [2, 1, 2])
@eachrow df begin 
    :A = cols(2)
end

@with df begin 
    cols(1) + cols(&quot;A&quot;)
end</code></pre><p>while the following will work without error</p><pre><code class="language-julia">@eachrow df begin 
    cols(1) = cols(2)
end

@with df begin 
    cols(1) + cols(2)
end</code></pre><p>Note that <code>cols</code> is <em>not</em> a standard Julia function. It is only used to modify the  way that macros in DataFramesMeta escape arguments and has no behavior of its own  outside of DataFramesMeta macros.</p><h1 id="Working-with-Symbols-without-referring-to-columns"><a class="docs-heading-anchor" href="#Working-with-Symbols-without-referring-to-columns">Working with <code>Symbol</code>s without referring to columns</a><a id="Working-with-Symbols-without-referring-to-columns-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Symbols-without-referring-to-columns" title="Permalink"></a></h1><p>To refer to <code>Symbol</code>s without aliasing the column in a data frame, use <code>^</code>. </p><pre><code class="nohighlight">df = DataFrame(x = [1, 1, 2, 2], y = [1, 2, 101, 102]);
@select(df, :x2 = :x, :x3 = ^(:x))</code></pre><p>This rule applies to all DataFramesMeta macros.</p><h2 id="Comparison-with-dplyr-and-LINQ"><a class="docs-heading-anchor" href="#Comparison-with-dplyr-and-LINQ">Comparison with <code>dplyr</code> and LINQ</a><a id="Comparison-with-dplyr-and-LINQ-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-with-dplyr-and-LINQ" title="Permalink"></a></h2><p>A number of functions for operations on DataFrames have been defined. Here is a table of equivalents for Hadley&#39;s <a href="https://github.com/hadley/dplyr">dplyr</a> and common <a href="http://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a> functions.</p><pre><code class="nohighlight">Julia             dplyr            LINQ
---------------------------------------------
@where            filter           Where
@transform        mutate           Select (?)
@by                                GroupBy
groupby           group_by         GroupBy
@combine          summarise/do
@orderby          arrange          OrderBy
@select           select           Select</code></pre><h2 id="Chaining-operations-together-with-@chain"><a class="docs-heading-anchor" href="#Chaining-operations-together-with-@chain">Chaining operations together with <code>@chain</code></a><a id="Chaining-operations-together-with-@chain-1"></a><a class="docs-heading-anchor-permalink" href="#Chaining-operations-together-with-@chain" title="Permalink"></a></h2><p>To enable connecting multiple commands together in  a pipe, DataFramesMeta.jl re-exports the <code>@chain</code> macro from  <a href="https://github.com/jkrumbiegel/Chain.jl">Chain.jl</a>. </p><pre><code class="language-julia">using Statistics 

df = DataFrame(a = repeat(1:5, outer = 20),
               b = repeat([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], inner = 25),
               x = repeat(1:20, inner = 5))

x_thread = @chain df begin
    @transform(:y = 10 * :x)
    @where(:a .&gt; 2)
    @by(:b, :meanX = mean(:x), :meanY = mean(:y))
    @orderby(:meanX)
    @select(:meanX, :meanY, :var = :b)
end</code></pre><p>By default, <code>@chain</code> places the value of the  previous expression into the first argument of the current expression. The placeholder <code>_</code> is used to break that convention and refer to the argument returned from the previous  expression.</p><pre><code class="language-julia"># Get the sum of all columns after 
# a few transformations
@chain df begin 
    @transform(:y = 10 .* :x)
    @where(:a .&gt; 2)
    @select(:a, :y, :x)
    reduce(+, eachcol(_))
end</code></pre><p><code>@chain</code> also provides the <code>@aside</code> macro-flag to perform operations in the middle of a <code>@chain</code> block. </p><pre><code class="language-julia">@chain df begin 
    @transform :y = 10 .* :x
    @aside y_mean = mean(_.y) # From Chain.jl, not DataFramesMeta.jl
    @select :y_standardize = :y .- y_mean
end</code></pre><ul><li><a href="api/api/#API">API</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Saturday 10 July 2021 13:38">Saturday 10 July 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
